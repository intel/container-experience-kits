##
##   Copyright (c) 2020-2023 Intel Corporation.
##
##   Licensed under the Apache License, Version 2.0 (the "License");
##   you may not use this file except in compliance with the License.
##   You may obtain a copy of the License at
##
##       http://www.apache.org/licenses/LICENSE-2.0
##
##   Unless required by applicable law or agreed to in writing, software
##   distributed under the License is distributed on an "AS IS" BASIS,
##   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##   See the License for the specific language governing permissions and
##   limitations under the License.
##
---
# Preflight: ALL checks must PASS
# Only assert issues (do NOT change anything)
#
# Manual run: 'ansible-playbook -i inventory.ini playbooks/preflight.yml --flush-cache'
#
# Summary:
# On Ansible Host (localhost):
# - Check Ansible version (match)
# - Check Python version (min)
# - Check Group Vars (exist)
# - Check Host Vars (exist for each worker node)
# On All targets (k8s_cluster):
# - Check Linux Distro
# - Check Hostnames (match Inventory)
# - Check if cpusets and isolcpus are enabled simultaneously
# - Check cpusets Total (not more than actual)
# - Check cpusets IDs (valid on system)
# - Check cpusets OS Reserved (not 0,1,etc)
# - Check isolcpus Total (not more than actual)
# - Check isolcpus IDs (valid on system)
# - Check isolcpus OS Reserved (not 0,1,etc)
# On Worker Nodes Only (kube_node):
# - Check DP Interfaces (is not empty)
# - Check DP Interfaces Name (optional)
# - Check DP Interfaces Bus Info (pciid)
# - Check QAT Devices Bus Info (pciid)
# - Check QAT SRIOV VFs (max)
# - Check SGX configuration
# - Check OVS DPDK Dependencies (for 1G Hugepages)
# - Check VPP Dependencies (for 2M Hugepages)
# - Check CNI Dependencies (for OVS DPDK or VPP and Hugepages)
# - Check SST (not on RHEL 8.2 or old OSs)
# - Warn BIOS VT-d (should be enabled)
# - Warn BIOS Intel Virtualization Technology (should be enabled)
# - Warn BIOS Hyper-Threading (should be enabled)
# - Warn collectd (kernel update needed on old OSs)
# - Check OVS DPDK Version Compatibility (for OVS support)
# - Check Intel Ethernet Operator configuration
# - Check Intel SR-IOV FEC Operator configuration
# On Role specific Only (k8s_cluster)
# - Check Observability compontents
# - Check MinIO requirements
# - Check Intent Driven Orchestration (IDO) dependencies

# additional vars required:
#  cek_supported_ansible_base: # must be version
#  cek_supported_python: # min version
#  cek_supported_distros: [] # list
#  cek_supported_distros_versions: [] # list


##################################
# Prerequisites for Ansible Host #
##################################
- hosts: 127.0.0.1
  any_errors_fatal: true
  connection: local
  become: false
  vars:
    cek_supported_ansible_base: 2.11.8
    cek_supported_python: 3

  tasks:

    - ansible.builtin.debug: msg="Ansible version is {{ ansible_version.string }}"
    - name: Check Ansible Version
      ansible.builtin.assert:
        that: (ansible_version.full is version_compare(cek_supported_ansible_base, '>='))
        msg: "Ansible version must be {{ cek_supported_ansible_base }}. Please update"

    - ansible.builtin.debug: msg="Python version is {{ ansible_python_version }}"
    - name: Check Python Version
      ansible.builtin.assert:
        that: (ansible_python_version is version_compare(cek_supported_python, '>='))
        msg: "Python version must be at least {{ cek_supported_python }}. Please update"

    - name: Check kubernetes provisioner
      ansible.builtin.assert:
        that:
          - kube_provisioner in ['rke2', 'kubespray']
        fail_msg: "kube_provisioner supports only 'rke2' and 'kubespray' values, please correct the configuration in groups/all.yml"
        success_msg: "kube_provisioner set to '{{ kube_provisioner }}'"
      when: kubernetes

    - name: Check kubespray version
      ansible.builtin.import_role:
        name: kubespray_check
        tasks_from: check_kubespray_version
      when:
        - kube_provisioner != 'rke2'
        - kubernetes

    - name: Check applied kubespray patch
      ansible.builtin.import_role:
        name: kubespray_patch
        tasks_from: preflight_checksum
      when:
        - kube_provisioner != 'rke2'
        - kubernetes

    - name: read Group Vars
      ansible.builtin.stat:
        path: "{{ inventory_dir }}/group_vars/"
      register: group_vars_details

    - name: Check Group Vars
      ansible.builtin.assert:
        that:
          - group_vars_details.stat.exists
          - group_vars_details.stat.isdir
        msg: "File group_vars/all.yml does NOT exist. Must be created per Guide"

    - name: read Host Vars
      ansible.builtin.stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: host_vars_details
      with_items: "{{ groups['kube_node'] }}"

    - name: check Host Vars
      ansible.builtin.assert:
        that:
          - item.stat.exists
          - item.stat.isreg
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ host_vars_details.results }}"

    - name: read VM Host Vars
      ansible.builtin.stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: vm_host_vars_details
      with_items: "{{ groups['vm_host'] }}"

    - name: check VM Host Vars
      ansible.builtin.assert:
        that:
          - item.stat.exists
          - item.stat.isreg
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"

    - name: set group_vars_profile variable
      ansible.builtin.set_fact:
        group_vars_profile: "{{ profile_name | default('not generated') }}"

    - name: show profile_name from group_vars
      ansible.builtin.debug:
        msg: "group_vars profile_name is: '{{ group_vars_profile }}'"

    - name: check ip is defined in inventory.ini
      ansible.builtin.shell: "set -o pipefail && cat {{ inventory_file }} | grep -v \"^#\""
      args:
        executable: /bin/bash
      changed_when: false
      failed_when: check_ip_status.rc != 0
      register: check_ip_status
      when: vm_enabled and (not on_vms | default(false))

    - name: check container_runtime value
      ansible.builtin.assert:
        that: container_runtime is in ['docker', 'containerd', 'crio']
        msg: Incorrect container_runtime value !!
          Make sure 'container_runtime' is in ['docker', 'containerd', 'crio']

    - name: handle the error for check passwordless access to VM hosts
      block:
        - name: check passwordless access to VM hosts
          ansible.builtin.command: >-
            ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no
            {{ hostvars[item]['ansible_user'] | default(ansible_env.USER, True) }}@{{ hostvars[item]['ip'] }}
            /bin/true
          with_items: "{{ groups['vm_host'] }}"
          changed_when: false
      rescue:
        - name: Print when passwordless authentication failed
          ansible.builtin.debug:
            msg: >
              "Current user: '{{ ansible_env.USER }}' does not have password less access to '{{ (ansible_failed_result.results[0].stderr).split(':')[0] }}'.
               Password less authentication have to be configured for all VM hosts. Use: 'ssh-copy-id <user>@<VM_host_ip>'
              See above, which one failed"
          failed_when: true
      when:
        - vm_enabled and (not on_vms | default(false))
        - "'ip=' in check_ip_status.stdout | regex_findall('^' + item + '.*$', multiline=True, ignorecase=True) | join(',')"

    # VMRA FQDN block in case if IP is not defined in inventory.ini
    - name: handle the error for checking hostname and passwordless access to VM hosts via hostname
      block:
        - name: set hostname configuration
          ansible.builtin.set_fact:
            hostname_check: "{{ ansible_hostname }}"
            hostname_fqdn_check: "{{ ansible_fqdn }}"
          with_items: "{{ groups['vm_host'] }}"

        - name: verify user defined hostname in inventory with in system hostname configuration
          ansible.builtin.assert:
            that:
              - (ansible_host == hostname_fqdn_check) or
                (ansible_host == hostname_check)
            fail_msg:
              - "Found hostname configuration in system not equal to user defined hostname in inventory {{ ansible_host }}"
              - "Please update correct hostname in inventory.ini"
            success_msg: "{{ ansible_host }} matches with hostname configuration found in system"
          with_items: "{{ groups['vm_host'] }}"

        - name: check passwordless access to VM hosts via FQDN
          ansible.builtin.command: >-
            ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no
            {{ hostvars[item]['ansible_user'] | default(ansible_env.USER, True) }}@{{ hostvars[item]['ansible_host'] }}
            /bin/true
          changed_when: false
          with_items: "{{ groups['vm_host'] }}"
      rescue:
        - name: Print when passwordless authentication failed
          ansible.builtin.debug:
            msg: >
              "Current user: '{{ ansible_env.USER }}' does not have password less access to '{{ (ansible_failed_result.results[0].stderr).split(':')[0] }}'.
               Password less authentication have to be configured for all VM hosts. Use: 'ssh-copy-id <user>@<VM_host_hostname>'
              See above, which one failed"
          failed_when: true
      when:
        - vm_enabled and (not on_vms | default(false))
        - ansible_host is defined
        - "'ip=' not in check_ip_status.stdout | regex_findall('^' + item + '.*$', multiline=True, ignorecase=True) | join(',')"

    - name: check scale variable value
      ansible.builtin.assert:
        that: scale | bool
        fail_msg: "scale variable must be set to one of the following values { yes, on, 1, true }, case insensitive"
        success_msg: "scale variable is set to {{ scale }} \ncluster scaling is enabled"
      when: scale is defined

    - name: check vm_recreate_existing variable value
      ansible.builtin.assert:
        that: not vm_recreate_existing | bool
        fail_msg: "vm_recreate_existing has to be false for cluster scaling case"
        success_msg: "vm_recreate_existing variable is set to {{ vm_recreate_existing }} for cluster scaling"
      when:
        - scale is defined
        - vm_enabled | default(false)

    - name: check k8s for rancher manager
      block:
        - name: check if kube_provisioner is rke2
          ansible.builtin.assert:
            that: kube_provisioner == 'rke2'
            fail_msg: "rancher manager is only supported on rke2 currently"
        - name: regex k8s version
          ansible.builtin.set_fact:
            kube_version_number: "{{ rke2_version | regex_search('(?<=v)\\d+\\.\\d+') }}"
        - name: assert kube_version_number
          ansible.builtin.assert:
            that: kube_version_number is version('1.28', '<=')
            fail_msg: "Maximum k8s version for rancher manager is v1.28, current version is v{{ kube_version_number }}, please update group_vars"
      when: rancher_manager_enabled is defined and rancher_manager_enabled

##############################################
# Prerequisites for Control and Worker Nodes #
##############################################
- hosts: k8s_cluster,vm_host
  any_errors_fatal: true
  gather_facts: true
  vars:
    cek_supported_distros: [RedHat, Rocky, Ubuntu]
    cek_supported_distros_versions: ['8.6', '9.0', '9.1', '9.2', '22.04', '24.04']
    cpusets_ranges: []
    cpusets_discretes: []
    isolcpus_ranges: []
    isolcpus_discretes: []
    isolcpus_list: []

  tasks:
    - name: end play for VM host
      ansible.builtin.meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

    - name: show mapping of inventory_hostname to real hostname
      ansible.builtin.debug:
        msg: "inventory_hostname = {{ inventory_hostname }} -> real hostname = {{ hostvars[inventory_hostname]['ansible_hostname'] }}"

    - name: fail if deployment is VMRA and isolcpus is enabled
      ansible.builtin.assert:
        that:
          - isolcpus is not defined
        fail_msg:
          - "isolcpus variable can't be used on VMRA deployment"
      when:
        - vm_enabled and (not on_vms | default(false))
        - inventory_hostname in groups['vm_host']
        - isolcpus_enabled

    - name: read Host Vars for VMs
      ansible.builtin.stat:
        path: "{{ inventory_dir }}/host_vars/{{ item.name }}.yml"
      register: vm_host_vars_details
      with_items: "{{ vms }}"
      delegate_to: localhost
      become: false
      when:
        - vm_enabled and (not on_vms | default(false))
        - inventory_hostname in groups['vm_host']
        - item.type == 'work'

    - name: check Host Vars for VMs
      ansible.builtin.assert:
        that:
          - item.stat.exists
          - item.stat.isreg
        msg: "File host_vars/{{ item.item.name }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"
      when:
        - vm_enabled and (not on_vms | default(false))
        - vm_host_vars_details
        - inventory_hostname in groups['vm_host']
        - not item.skipped | default(false)

    - name: Check VM root password
      block:
        - name: check vm_hashed_passwd presence
          ansible.builtin.assert:
            that:
              - vm_hashed_passwd is defined
            fail_msg:
              - "Variable vm_hashed_passwd is not defined"
            success_msg: "vm_hashed_passwd is present"

        - name: check vm_hashed_passwd is not a placeholder
          ansible.builtin.assert:
            that:
              - vm_hashed_passwd is defined
              - vm_hashed_passwd != "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
            fail_msg:
              - "vm_hashed_passwd was not set with hashed password. Create hashed password and run deployment again."
            success_msg: "vm_hashed_passwd verified"
      when:
        - vm_enabled and (not on_vms | default(false))
        - inventory_hostname in groups['vm_host']

# Host mixed with VM hosts setup, must have VXLAN physical interface to connect to VMs
    - name: Check requirements to enable mixed deployment
      when:
        - vm_enabled and (not on_vms | default(false))
        - inventory_hostname in groups['k8s_cluster']
        - hostvars[inventory_hostname]['ansible_virtualization_role']|default('') != 'guest'
      block:
        - name: check if mandatory parameter 'vxlan_physical_network' is present for the baremetal host
          assert:
            that:
              - vxlan_physical_network is defined
            msg: |
              "vxlan_physical_network parameter is not defined for host '{{ inventory_hostname }}'"
              "Please correct the configuration"

        - name: check if mandatory parameter 'vxlan_physical_network' for the baremetal host has valid IP subnet
          assert:
            that:
              - vxlan_physical_network | ansible.utils.ipaddr('net')
            msg: |
              "vxlan_physical_network parameter for the host '{{ inventory_hostname }}' does not have valid IP subnet"
              "Current value is '{{ vxlan_physical_network }}'"
              "Please correct the configuration"

        - name: check if VXLAN physical network is available
          assert:
            that: hostvars[inventory_hostname]['ansible_all_ipv4_addresses'] | ansible.utils.ipaddr(vxlan_physical_network) | length > 0
            msg: |
              "vxlan_physical_network '{{ vxlan_physical_network }}' is not available on host '{{ inventory_hostname }}'"
              "Please correct the configuration or update network setup to ensure proper connectivity with vm_hosts"

        - name: check if mandatory parameter 'vxlan_gw_ip' is present for the baremetal host
          assert:
            that:
              - vxlan_gw_ip is defined
            msg: |
              "vxlan_gw_ip parameter is not defined for host '{{ inventory_hostname }}'"
              "Please correct the configuration"

        - name: check if mandatory parameter 'vxlan_gw_ip' for the baremetal host has valid IP
          assert:
            that:
              - vxlan_gw_ip | ansible.utils.ipaddr('address')
            msg: |
              "vxlan_gw_ip parameter for the host '{{ inventory_hostname }}' does not have valid IP"
              "Current value is '{{ vxlan_gw_ip }}'"
              "Please correct the configuration"

# VMs multinode setup for VM Hosts (including VM + BM mixed case)
    - name: Check requirements to enable VMs multinode setup
      when:
        - vm_enabled and (not on_vms | default(false))
        - "(groups['vm_host'] | length > 1) or \
          ('k8s_cluster' in group_names and hostvars[inventory_hostname]['ansible_virtualization_role']|default('') != 'guest')"
      block:
        - name: check if mandatory parameter 'dhcp' is present on vm_host[0]
          assert:
            that:
              - hostvars[groups['vm_host'][0]]['dhcp'] | default([]) | length
            msg: |
              "vxlan dhcp must be defined on {{ groups['vm_host'][0] }} for multiple hosts deployment"
          run_once: true

        - name: check if mandatory parameter 'vxlan_physical_network' is present for the first vm_host
          ansible.builtin.assert:
            that:
              - hostvars[groups['vm_host'][0]]['vxlan_physical_network'] is defined
            msg: |
              "vxlan_physical_network parameter is not defined for the first vm_host '{{ groups['vm_host'][0] }}'"
              "Please correct the configuration"
          run_once: true

        - name: check if mandatory parameter 'vxlan_physical_network' for the first vm_host has valid IP subnet
          ansible.builtin.assert:
            that:
              - hostvars[groups['vm_host'][0]]['vxlan_physical_network'] | ansible.utils.ipaddr('net')
            msg: |
              "vxlan_physical_network parameter for the first vm_host '{{ groups['vm_host'][0] }}' does not have valid IP subnet"
              "Current value is '{{ hostvars[groups['vm_host'][0]]['vxlan_physical_network'] }}'"
              "Please correct the configuration"
          run_once: true

        - name: check if VXLAN physical network is available
          ansible.builtin.assert:
            that:
              hostvars[inventory_hostname]['ansible_all_ipv4_addresses'] |
              ansible.utils.ipaddr(hostvars[groups['vm_host'][0]]['vxlan_physical_network']) |
              length > 0
            msg: |
              "vxlan_physical_network '{{ hostvars[groups['vm_host'][0]]['vxlan_physical_network'] }}' is not available on vm_host '{{ inventory_hostname }}'"
              "Please correct the configuration or update network setup to ensure proper connectivity between vm_hosts"

    - name: check for ip and ansible_host mismatch
      ansible.builtin.assert:
        that: ansible_host == ip
        msg: "Configuration mismatch detected between ansible_host={{ ansible_host }} and ip={{ ip }} on target '{{ inventory_hostname }}'"
      when:
        - ansible_host is defined
        - ip is defined
        - ansible_host | ansible.utils.ipaddr('bool')
        - not adq_dp['enabled'] | default(false)
        - not calico_vpp['enabled'] | default(false)

    - ansible.builtin.debug:
        msg: "Linux distribution on target is {{ ansible_distribution }} {{ ansible_distribution_version }} {{ ansible_distribution_release }}"
    - name: Check Linux Distro and Version
      ansible.builtin.assert:
        that:
          - ansible_distribution in cek_supported_distros
          - ansible_distribution_version in cek_supported_distros_versions
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}' is NOT supported
          - Must be one of {{ cek_supported_distros }} and version {{ cek_supported_distros_versions }}

#    - name: Check Linux Across Cluster
# TODO ?? Linux OS must be the same on all targets (no mix-n-match)

    - name: regather network facts in case hostname recently changed
      ansible.builtin.setup:
        gather_subset: network
    - ansible.builtin.debug: msg="Inventory target '{{ inventory_hostname }}' has the actual system hostname '{{ ansible_hostname }}'"
    - name: Check Inventory Hostnames
      ansible.builtin.debug:
        msg:
          - "Target '{{ inventory_hostname }}' in inventory does NOT match the actual system hostname '{{ ansible_hostname }}'."
          - "If it's done intentionally, please ignore this message."
      when:
        - inventory_hostname != ansible_hostname

# Early check if SELinux is configured properly
    - block:
        - name: "Collect packages facts"
          ansible.builtin.package_facts:
        - ansible.builtin.debug:
            msg:
              - "Current SELinux status:"
              - "status: {{ ansible_selinux.status | default('') }}"
              - "policy version:  {{ ansible_selinux.policyvers | default('') }}"
              - "type: {{ ansible_selinux.type | default('') }}"
              - "mode: {{ ansible_selinux.mode | default('') }}"
              - "config_mode: {{ ansible_selinux.config_mode | default('') }}"

        - name: check SELinux condition possibly causing system boot failure
          ansible.builtin.debug:
            msg:
              - "Current SELinux setup might cause the system possibly will not boot up on next reboot."
              - "Please, check SELinux settings and set it up according to the documentation."
          when:
            - "'selinux-policy' not in ansible_facts.packages"
            - "'selinux-policy-targeted' not in ansible_facts.packages"

        - name: check SELinux configuration for CRI-O runtime
          ansible.builtin.assert:
            that:
              - (ansible_selinux.status == "enabled" and selinux_state is defined and selinux_state == "disabled") or
                (ansible_selinux.status != "enabled" and selinux_state is defined and selinux_state != "enabled")
            fail_msg: "CRI-O runtime requires SELinux in disabled state. Please, set selinux_state variable to 'disabled'"
            success_msg: "CRI-O runtime SELinux configuration verified"
          when:
            - container_runtime == "crio"
      when:
        - ansible_os_family == "RedHat"

    - name: check kubernetes and container runtime variables
      ansible.builtin.assert:
        that:
          - (not kubernetes and container_runtime_only_deployment) or
            (not kubernetes and not container_runtime_only_deployment)
        fail_msg: >-
          "For container runtime only deployment set container_runtime_only_deployment as "true" and kubernetes as "false".
          Set both variables as "false" to perform only host configuration."
      when:
        - not kubernetes or container_runtime_only_deployment

    - name: check k8s version
      ansible.builtin.assert:
        that: kube_version is version('v1.26', '>=')
        msg: "Minimum supported k8s version is 1.26, please update kube_version variable with correct version"
      when: kubernetes and not container_runtime_only_deployment

    - name: check RKE2 requirements
      ansible.builtin.include_role:
        name: rke2_defaults
        tasks_from: rke2_preflight
      when: kube_provisioner == "rke2"

    - name: assert that Multus is enabled in the config
      ansible.builtin.assert:
        that:
          - kube_network_plugin_multus | default(false)
        fail_msg: "SRIOV and the Userspace CNI plugin require Multus for a fully functional cluster deployment"
      when: sriov_net_dp_enabled is defined and sriov_net_dp_enabled or
            sriov_cni_enabled is defined and sriov_cni_enabled or
            userspace_cni_enabled is defined and userspace_cni_enabled

    - name: assert that SRIOV Network Operator/SRIOV Network DP are mutually exclusive
      ansible.builtin.assert:
        that:
          - not sriov_net_dp_enabled | default(false)
        fail_msg:
          - "SRIOV Network Operator is enabled, SRIOV Network DP/SRIOV CNI should be disabled !!"
      when: sriov_network_operator_enabled is defined and sriov_network_operator_enabled

# check cpusets CPU core/threads shielding configuration
    - block:
        - ansible.builtin.debug:
            msg:
              - cpusets_enabled = {{ cpusets_enabled }} (host_vars)
              - cpusets = {{ cpusets }} (host_vars)
              - ansible_processor_count = {{ ansible_processor_count }}
              - ansible_processor_cores = {{ ansible_processor_cores }}
              - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
              - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
              - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}
  #            - CPUs Reserved for OS = {{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }} # [E207] Nested jinja pattern

        - name: check OS for cpusets based on cgroups v1 only
          ansible.builtin.assert:
            that:
              - ansible_distribution == "Ubuntu"
              - ansible_distribution_version is version('20.04', '==')
            msg:
              - Unsupported configuration.
              - CPUs isolation ('cpusets') can be only enabled on Ubuntu 20.04.x.

        - name: check CPUs isolation
          ansible.builtin.assert:
            that: cpusets | length > 0
            msg:
              - Incorrect configuration. Conflicting or improper values detected
              - CPUs isolation ('cpusets') must be set according to the example file for host_vars. Please correct the configuration

        - name: split cpusets Groups
          ansible.builtin.set_fact:
            cpusets_groups: "{{ cpusets.split(',') }}"

        - ansible.builtin.debug: msg="cpusets_groups = {{ cpusets_groups }}"

        - name: filter cpusets Ranges
          ansible.builtin.set_fact:
            cpusets_ranges: "{{ cpusets_ranges + [item] }}"
          with_items: "{{ cpusets_groups }}"
          when: ("-" in item)

        - ansible.builtin.debug: msg="cpusets_ranges = {{ cpusets_ranges }}"

        - name: filter cpusets Discretes
          ansible.builtin.set_fact:
            cpusets_discretes: "{{ cpusets_discretes + [item] }}"
          with_items: "{{ cpusets_groups }}"
          when: ("-" not in item)

        - ansible.builtin.debug: msg="cpusets_discretes = {{ cpusets_discretes }}"

        - name: build cpusets List
          ansible.builtin.set_fact:
            cpusets_list: "{{ cpusets_list | default([]) | union(cpusets_discretes) | union([item]) }}"
          with_sequence: "{{ cpusets_ranges }}"

        - ansible.builtin.debug: msg="cpusets_list = {{ cpusets_list }}"

        - name: check cpusets Total
          ansible.builtin.assert:
            that: cpusets_list | length <= ansible_processor_vcpus
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The number of cpusets {{ cpusets_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

        - name: check cpusets IDs
          ansible.builtin.assert:
            that: item | int <= ansible_processor_vcpus
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The CPU ID {{ item }} set for cpusets is NOT actually present on target. Please correct the configuration
          with_items: "{{ cpusets_list }}"

        - name: check cpusets OS Reserved
          ansible.builtin.assert:
            that: item not in cpusets_list
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for cpusets. Please correct the configuration
          with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - cpusets_enabled is defined and cpusets_enabled | bool

# check isolcpus CPU core/threads configuration
    - block:
        - ansible.builtin.debug:
            msg:
              - isolcpus_enabled = {{ isolcpus_enabled }} (host_vars)
              - isolcpus = {{ isolcpus }} (host_vars)
              - ansible_processor_count = {{ ansible_processor_count }}
              - ansible_processor_cores = {{ ansible_processor_cores }}
              - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
              - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
              - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}

        - name: check CPUs isolation
          ansible.builtin.assert:
            that: isolcpus | length > 0
            msg:
              - Incorrect configuration. Conflicting or improper values detected
              - CPUs isolation ('isolcpus') must be set according to the example file for host_vars. Please correct the configuration

        - name: split isolcpus Groups
          ansible.builtin.set_fact:
            isolcpus_groups: "{{ isolcpus.split(',') }}"

        - ansible.builtin.debug: msg="isolcpus_groups = {{ isolcpus_groups }}"

        - name: filter isolcpus Ranges
          ansible.builtin.set_fact:
            isolcpus_ranges: "{{ isolcpus_ranges + [item] }}"
          with_items: "{{ isolcpus_groups }}"
          when: ("-" in item)

        - ansible.builtin.debug: msg="isolcpus_ranges = {{ isolcpus_ranges }}"

        - name: filter isolcpus Discretes
          ansible.builtin.set_fact:
            isolcpus_discretes: "{{ isolcpus_discretes + [item] }}"
          with_items: "{{ isolcpus_groups }}"
          when: ("-" not in item)

        - ansible.builtin.debug: msg="isolcpus_discretes = {{ isolcpus_discretes }}"

        - name: build isolcpus List
          ansible.builtin.set_fact:
            isolcpus_list: "{{ isolcpus_list | default([]) | union(isolcpus_discretes) | union([item]) }}"
          with_sequence: "{{ isolcpus_ranges }}"

        - ansible.builtin.debug: msg="isolcpus_list = {{ isolcpus_list }}"

        - name: check isolcpus Total
          ansible.builtin.assert:
            that: isolcpus_list | length <= ansible_processor_vcpus
            msg: |
              Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              The number of isolcpus {{ isolcpus_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

        - name: check isolcpus IDs
          ansible.builtin.assert:
            that: item | int <= ansible_processor_vcpus
            msg:
              - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              - The CPU ID {{ item }} set for isolcpus is NOT actually present on target. Please correct the configuration
          with_items: "{{ isolcpus_list }}"

        - name: check isolcpus OS Reserved
          ansible.builtin.assert:
            that: item not in isolcpus_list
            msg:
              - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for isolcpus. Please correct the configuration
          with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - isolcpus_enabled is defined and isolcpus_enabled | bool
        - isolcpus is defined and isolcpus

    - name: check Intel CPU Control Plane configuration
      ansible.builtin.include_role:
        name: intel_cpu_controlplane
        tasks_from: preflight_cpu_controlplane.yml
      when:
        - kubernetes
        - intel_cpu_controlplane is defined and intel_cpu_controlplane.enabled
      tags:
        - cpu_ctlplane

    - name: check Intel Media Analytics configuration
      ansible.builtin.import_role:
        name: intel_media_analytics
        tasks_from: preflight_intel_media_analytics.yml
      when:
        - kubernetes
        - intel_media_analytics_enabled | default(false)
      tags:
        - intel-media-analytics

    - name: Check KubeVirt configuration
      ansible.builtin.import_role:
        name: kubevirt_install
        tasks_from: preflight.yml
      when:
        - kubernetes | default(false)
        - kubevirt_enabled | default(false)
      tags: kubevirt

    - name: Check Infrstructure Power Manager configuration
      ansible.builtin.import_role:
        name: infrastructure_power_manager
        tasks_from: preflight.yml
      when:
        - infrastructure_power_manager_enabled | default(false)
      tags: infra-power-manager

####################################
# Prerequisites for Worker Node(s) #
####################################
- hosts: kube_node,vm_host
  any_errors_fatal: true
  vars:
    phy_nics_pciids: []
  vars_files:
    - "../roles/check_machine_type/vars/main.yml"

  tasks:
    - name: end play for VM host
      ansible.builtin.meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

# STORY: "nic bus info specified is present on system"
    - ansible.builtin.debug:
        msg: "Dataplane (DP) interface(s) defined in host_vars = {{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined

    - name: assert that (SRIOV Network DP/SRIOV CNI) and (SRIOV Network Operator) are mutually exclusive
      ansible.builtin.assert:
        that:
          - not (sriov_net_dp_enabled | default(false) and sriov_network_operator_enabled | default(false))
        fail_msg:
          - "SRIOV Network DP/SRIOV CNI and SRIOV Network Operator are mutually exclusive. One must be disabled"
      when:
        - (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_net_dp_enabled is defined and sriov_net_dp_enabled)

    - name: check DP Interfaces
      ansible.builtin.assert:
        that: dataplane_interfaces != []
        msg: "Dataplane (DP) interface(s) on target '{{ ansible_hostname }}' must be set in host_vars. Please correct the configuration"
      when:
        - profile_name != 'build_your_own'
        - dataplane_interfaces is defined
        - (update_nic_drivers is defined and update_nic_drivers) or
          (install_ddp_packages is defined and install_ddp_packages) or
          (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_network_operator_enabled is defined and sriov_network_operator_enabled)

    # FlexRAN needs 2 NIC PFs
    - name: check DP Interfaces PF numbers for FlexRAN
      ansible.builtin.assert:
        that:
          - dataplane_interfaces[0].bus_info is defined
          - dataplane_interfaces[1].bus_info is defined
        msg: "For FlexRAN, 2 Dataplane (DP) interface(s) on target '{{ ansible_hostname }}' are needed. Please correct the configuration"
      when:
        - intel_flexran_enabled | default(false)

    - ansible.builtin.debug:
        msg: "Network interfaces present on target '{{ ansible_hostname }}' = {{ ansible_interfaces }}"

    - name: read Physical NICs PCIIDs
      ansible.builtin.set_fact:
        phy_nics_pciids: "{{ phy_nics_pciids + [ ansible_facts[item]['pciid'] | regex_replace('0000:(.*)', '\\1')  ] }}"
      with_items: "{{ ansible_interfaces }}"
      when: ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"

    - ansible.builtin.debug: msg="PCI Slots for the NICs on target '{{ ansible_hostname }}' = {{ phy_nics_pciids }}"

    - name: check DP Interfaces Bus Info
      ansible.builtin.assert:
        that: item.bus_info in phy_nics_pciids
        msg: "Dataplane interface defined with PCI ID '{{ item.bus_info }}' does NOT exist on target. Please correct the configuration"
      with_items: "{{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined and dataplane_interfaces != []

    - name: load firmware specific variables
      include_vars: "../roles/bootstrap/update_nic_firmware/defaults/main.yml"
      when: nvmupdate is not defined

    - name: check nic firmware version needed for loading of DDP profile
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_ddp_loadable_fw_version }}"
        ddp: true
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - install_ddp_packages is defined and install_ddp_packages
        - not update_nic_firmware | default(false)

    - name: check nic firmware version needed for automatic firmware update
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_updatable_fw_version }}"
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - update_nic_firmware | default(false)

    - name: Check first DP interface driver and DDP package
      block:
        - name: Check first DP interface driver
          ansible.builtin.assert:
            that: dataplane_interfaces[0].pf_driver == ansible_facts[item]['module']
            msg: >-
              "Dataplane interface '{{ dataplane_interfaces[0].bus_info }}' 'pf_driver' is set to '{{ dataplane_interfaces[0].pf_driver }}'.
              Please, set it to '{{ ansible_facts[item]['module'] }}'."
          loop: "{{ ansible_interfaces }}"
          when:
            - ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"
            - dataplane_interfaces[0].bus_info in ansible_facts[item]['pciid']

        - name: check if selected DDP package corresponds PF driver ice
          ansible.builtin.assert:
            that: dataplane_interfaces[0].ddp_profile is regex('^ice_comms*')
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "ice"
            - install_ddp_packages is defined and install_ddp_packages

        - name: check if selected DDP package corresponds PF driver i40e
          ansible.builtin.assert:
            that: dataplane_interfaces[0].ddp_profile in ddp_profiles_allowed
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "i40e"
            - install_ddp_packages is defined and install_ddp_packages
          vars:
            ddp_profiles_allowed:
              - ecpri.pkg
              - esp-ah.pkg
              - ppp-oe-ol2tpv2.pkgo
              - mplsogreudp.pkg
              - gtp.pkgo
      when:
        - dataplane_interfaces is defined and dataplane_interfaces | length > 0

    - name: check total SRIOV VFs required for NIC device auto detection on VMs
      ansible.builtin.include_role:
        name: bootstrap/auto_detect_nic_devices # noqa role-name[path]
        tasks_from: preflight
      when:
        - vms is defined
        - dataplane_interfaces is defined
        - dataplane_interfaces | default([]) | length == 0
        - (update_nic_drivers is defined and update_nic_drivers) or
          (install_ddp_packages is defined and install_ddp_packages) or
          (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_network_operator_enabled is defined and sriov_network_operator_enabled)

    - name: Print processor info
      ansible.builtin.debug:
        msg: "ansible_processor model: {{ ansible_processor[2] }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: set CPU ID in preflight
      ansible.builtin.set_fact:
        cpu_id: "{{ ansible_processor[2] | regex_search('\\$?\\d\\d\\d\\d\\%?\\@?\\w?|\\d\\d/\\d\\w') }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: add dummy CPU ID for GNR in preflight
      ansible.builtin.set_fact:
        cpu_id: "9999"
      when:
        - (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))
        - cpu_id | length == 0

    - name: print CPU ID
      ansible.builtin.debug:
        msg: "CPU ID: {{ cpu_id }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: check if CPU has confirmed support (preflight)
      ansible.builtin.assert:
        that: cpu_id in lookup('ansible.builtin.vars', 'confirmed_' + configured_arch + '_cpus')
               {% if configured_arch == 'clx' %} or cpu_id in confirmed_clx_ncpus {% endif %}
               or cpu_id in unconfirmed_cpu_models
        fail_msg:
          "CPU model '{{ cpu_id }}' present on target is not in the confirmed CPUs list.\n
          To proceed, please add  '{{ cpu_id }}' to the list of unconfirmed CPUs in variable 'unconfirmed_cpu_models' in group_vars.\n
          Please be aware that by using CPU model that is not confirmed, some features may not work properly."
      when:
        - (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))
        - configured_arch not in ['atom', 'core', 'ultra']
        - hostvars[inventory_hostname]['ansible_virtualization_role']|default('') != 'guest'

    - name: check ubuntu pro token is not a placeholder
      ansible.builtin.assert:
        that:
          - ubuntu_pro_token is defined
          - ubuntu_pro_token != "ffffffffffffffffffffffffffffff"
        fail_msg:
          - "Please, visit https://ubuntu.com/pro to apply the token for rt kernel install."
          - "And update ubuntu_pro_token placeholder inside group_vars with real token."
        success_msg: "ubuntu_pro_token verified"
      when:
        - rt_kernel_enabled | default(false)

    - name: check NDA QAT drvier package
      block:
        - name: print debug message NDA QAT driver package
          ansible.builtin.debug:
            msg="Expecting file {{ (nda_qat_driver_folder, nda_qat_driver_package) | path_join }} for {{ configured_arch }} on local ansible host"
        - name: probe for NDA QAT driver package
          delegate_to: localhost
          become: false
          ansible.builtin.stat:
            path: "{{ (nda_qat_driver_folder, nda_qat_driver_package) | path_join }}"
            checksum_algorithm: sha1
          register: nda_qat_driver
        - name: print debug message for NDA QAT driver existence
          ansible.builtin.debug:
            msg="{{ nda_qat_driver_package }} exists is {{ nda_qat_driver.stat.exists }}"
        - name: check NDA QAT driver files exists
          ansible.builtin.assert:
            that: nda_qat_driver.stat.exists
            msg: |
              Mandatory file {{ (nda_qat_driver_folder, nda_qat_driver_package) | path_join }} does NOT exist on localhost.
              Please acquire the zip file and place it in the location indicated above in order to deploy NDA QAT. See docs/{{ configured_arch }}.md
        - name: check the qat driver package integrity
          ansible.builtin.assert:
            that: nda_qat_driver.stat.checksum == nda_qat_driver_pkg_checksum
            msg: |
              File {{ (nda_qat_driver_folder, nda_qat_driver_package) | path_join }} on localhost is NOT the expected one.
              Real checksum -> {{ nda_qat_driver.stat.checksum }}, expected checksum > {{ nda_qat_driver_pkg_checksum }}
              Please provide the correct file. See docs/{{ configured_arch }}.md
      when:
        - update_qat_drivers | default(false)
        - configured_arch in ['emr', 'gnr']
        - configured_arch == 'gnr' and (ansible_distribution != "Rocky" or (ansible_distribution == "Rocky" and ansible_distribution_version != "9.2"))

    - name: check NDA QAT drvier package for Rocky 9.2
      block:
        - name: print debug message NDA QAT driver package for Rocky
          ansible.builtin.debug:
            msg="Expecting file {{ (nda_qat_driver_folder, nda_qat_driver_package_rocky) | path_join }} for {{ configured_arch }} on local ansible host"
        - name: probe for NDA QAT driver package for Rocky
          delegate_to: localhost
          become: false
          ansible.builtin.stat:
            path: "{{ (nda_qat_driver_folder, nda_qat_driver_package_rocky) | path_join }}"
            checksum_algorithm: sha1
          register: nda_qat_driver
        - name: print debug message for NDA QAT driver existence for Rocky
          ansible.builtin.debug:
            msg="{{ nda_qat_driver_package_rocky }} exists is {{ nda_qat_driver.stat.exists }}"
        - name: check NDA QAT driver files exists for Rocky
          ansible.builtin.assert:
            that: nda_qat_driver.stat.exists
            msg: |
              Mandatory file {{ (nda_qat_driver_folder, nda_qat_driver_package_rocky) | path_join }} does NOT exist on localhost.
              Please acquire the zip file and place it in the location indicated above in order to deploy NDA QAT. See docs/{{ configured_arch }}.md
        - name: check the qat driver package integrity for Rocky
          ansible.builtin.assert:
            that: nda_qat_driver.stat.checksum == nda_qat_driver_pkg_checksum_rocky
            msg: |
              File {{ (nda_qat_driver_folder, nda_qat_driver_package_rocky) | path_join }} on localhost is NOT the expected one.
              Real checksum -> {{ nda_qat_driver.stat.checksum }}, expected checksum > {{ nda_qat_driver_pkg_checksum_rocky }}
              Please provide the correct file. See docs/{{ configured_arch }}.md
      when:
        - update_qat_drivers | default(false)
        - configured_arch in ['gnr']
        - ansible_distribution == "Rocky" and ansible_distribution_version is version('9.2', '==')

    - name: check QAT SVM precheck
      ansible.builtin.assert:
        that:
          - update_qat_drivers
        fail_msg: "qat svm only works on the Out of tree driver, please set the update_qat_drivers to true in host_vars."
      when:
        - enable_qat_svm | default(false) | bool

    - name: check QAT Devices list is configured properly
      block:
        - ansible.builtin.debug:
            msg: "QAT device(s) defined in host_vars = {{ qat_devices }}"

        - name: read QAT PCIIDs
          ansible.builtin.shell: "set -o pipefail && lspci -d 8086: -nn -D | egrep -i '{{ qat_supported_pf_dev_ids | join('|') }}'"
          args:
            executable: /bin/bash
          register: lspci_qat_host
          changed_when: false
          failed_when: false
          when:
            - on_vms is not defined or not on_vms

        - name: assert QAT PCIIDs
          ansible.builtin.assert:
            that: lspci_qat_host.rc == 0
            fail_msg: "No QAT devices were found in system. Please configure properly the QAT PCIIDs in group_vars or disable this feature"
            success_msg: "QAT PCIIDs verification completed"
          when:
            - on_vms is not defined or not on_vms

        - name: read QAT PCIIDs on VMs
          ansible.builtin.shell: "set -o pipefail && lspci -d 8086: -nn -D | egrep -i '{{ (qat_supported_vf_dev_ids + qat_supported_pf_dev_ids) | join('|') }}'"
          args:
            executable: /bin/bash
          register: lspci_qat_vms
          changed_when: false
          when:
            - on_vms is defined and on_vms

        - name: store lspci_qat
          ansible.builtin.set_fact:
            lspci_qat: "{% if (on_vms is defined and on_vms) %}{{ lspci_qat_vms }}{% else %}{{ lspci_qat_host }}{% endif %}"

        - ansible.builtin.debug:
            msg: "QAT devices found on target = {{ lspci_qat.stdout }}"

        - name: check QAT Devices' Bus Info
          ansible.builtin.assert:
            that: item.qat_id in lspci_qat.stdout
            msg: "QAT device defined with PCI ID '{{ item.qat_id }}' does NOT exist on target. Please correct the configuration"
          with_items: "{{ qat_devices }}"
        # STORY: "qat_sriov_numvfs should not exceed max supported (16) per each dev_ID"
        - ansible.builtin.debug:
            msg:
              - qat_sriov_numvfs for {{ item.qat_id }} = {{ item.qat_sriov_numvfs }} (host_vars)
              - update_qat_drivers = {{ update_qat_drivers }} (host_vars)
          with_items: "{{ qat_devices }}"

        - name: check QAT SRIOV VFs
          ansible.builtin.assert:
            that: item.qat_sriov_numvfs <= 16
            msg:
              - Incorrect configuration pertaining QAT SRIOV. Conflicting or improper values detected
              - When SRIOV VFs are set for QAT, max value is 16 for each ID (max 48 total per card). Please correct the configuration
          with_items: "{{ qat_devices }}"
      when:
        - update_qat_drivers | default(false)
        - qat_devices is defined and qat_devices != []

    - name: check total SRIOV VFs required for QAT device auto detection on VMs
      ansible.builtin.include_role:
        name: bootstrap/auto_detect_qat_devices # noqa role-name[path]
        tasks_from: preflight
      when:
        - vms is defined
        - update_qat_drivers | default(false)
        - qat_devices is defined and qat_devices == []

    - name: Check GPU hardware requirements
      ansible.builtin.include_role:
        name: gpu_dp_install
        tasks_from: preflight_gpu_dp
      when:
        - gpu_dp_enabled is defined and gpu_dp_enabled
        - profile_name != "on_prem_aibox"

    - name: Check Intel In-Band Manageability configuration
      ansible.builtin.include_role:
        name: intel_inband_manageability
        tasks_from: preflight
      when:
        - intel_inband_manageability.enabled | d(false)

    - name: Check GPU device plugin state
      ansible.builtin.assert:
        that:
          - gpu_dp_enabled
        fail_msg: "GPU device plugin is disabled. Please set gpu_dp_enabled to true in group_vars."
        success_msg: "GPU device plugin is enabled"
      when:
        - configure_gpu is defined and configure_gpu
        - profile_name != "on_prem_aibox"

    - name: FPGA environment preflight check
      block:
        - name: FPGA OS precheck
          ansible.builtin.assert:
            that:
              - ansible_distribution == "Ubuntu"
              - ansible_distribution_version is version('22.04', '==')
            msg: >-
              Currently fpga is only supported on Ubuntu 22.04.

        - name: fpga dependencies check
          ansible.builtin.assert:
            that:
              - hugepages_enabled
              - iommu_enabled
            msg:
              - "fpga has dependency on hugepages and iommu, please enable them firstly in the host_vars yaml file."

        - name: probe fpga driver installation script
          delegate_to: localhost
          become: false
          ansible.builtin.stat:
            path: "{{ (fpga_driver_staging_folder, fpga_install_script) | path_join }}"
          register: fpga_register

        - name: check fpga install scripts exists
          ansible.builtin.assert:
            that: fpga_register.stat.exists
            msg:
              - "Mandatory file {{ (fpga_driver_staging_folder, fpga_install_script) | path_join }} does NOT exist on localhost."
              - "Please acquire the file from Intel Resource and Design Center and place it in the location indicated above in order to deploy fpga."
      when:
        - configure_fpga is defined and configure_fpga

    - name: check OpenSSL and OpenSSL*Engine requirements when OOT or Intree QAT setup configured
      ansible.builtin.assert:
        that:
          - openssl_install
        fail_msg: "OpenSSL & OpenSSL*Engine must be configured if configure_qat is set to 'true'"
        success_msg: "Assertion of OpenSSL & OpenSSL*Engine for QAT passed"
      when:
        - configure_qat | default(false) | bool

    - name: check gas(gpu aware scheduling) configuration
      ansible.builtin.assert:
        that:
          - gpu_dp_enabled
          - gpu_dp_fractional_manager
        fail_msg: "gas installation requires gpu_dp_enabled and gpu_dp_fractional_manager set to true"
        success_msg: "gas requirement verified"
      when:
        - gas_enabled | default(false)

    - name: check KMRA sgx_dp requirements
      ansible.builtin.assert:
        that:
          - sgx_dp_enabled
        fail_msg: "KMRA installation requires sgx_dp_enabled set to 'true'"
        success_msg: "KMRA sgx_dp requirements verified"
      when:
        - kmra.ctk_loadkey_demo.enabled | default(false) or
          kmra.pccs.enabled | default(false) or
          kmra.apphsm.enabled | default(false)

    - name: check KMRA sbx requirements
      ansible.builtin.include_role:
        name: kmra_install
        tasks_from: kmra_sbx_preflight
      when:
        - kmra.sbx | default(false)

    - name: make sure netopeer2 server/client is off when oran disabled
      ansible.builtin.assert:
        that:
          - not (kmra.oran_netopeer2_server.enabled | default(false))
          - not (kmra.oran_netopeer2_client.enabled | default(false))
        fail_msg: "oran disabled, so netopeer2 server/client cannot set"
      when:
        - not kmra.oran.enabled | default(false)

    - name: check KMRA oran requirements
      ansible.builtin.include_role:
        name: kmra_install
        tasks_from: kmra_oran_preflight
      when:
        - kmra.oran.enabled | default(false)

    - name: check Intel SGX DP configuration
      ansible.builtin.assert:
        that:
          - configure_sgx is defined
          - configure_sgx
        fail_msg:
          - "Please set configure_sgx to true in host vars to allow SGX configuration on the system"
      when:
        - sgx_dp_enabled is defined and sgx_dp_enabled

    - name: check if Cert Manager is required
      ansible.builtin.assert:
        that:
          - cert_manager_enabled | default(false)
        fail_msg:
          - "Cert Manager required by following components: Intel Device Plugins, observability stack, NFD, LinkerD."
          - "Please set cert_manager_enabled to 'true' in group_vars"
        success_msg: "Cert Manager is enabled as required"
      when:
        - nfd_enabled | default(false) or
          sgx_dp_enabled | default(false) or
          dlb_dp_enabled | default(false) or
          qat_dp_enabled | default(false) or
          gpu_dp_enabled | default(false) or
          dsa_dp_enabled | default(false) or
          qat_dp_enabled | default(false) or
          jaeger_enabled | default(false) or
          telegraf_enabled | default(false) or
          prometheus_stack_enabled | default(false) or
          opentelemetry_enabled | default(false) or
          eck_enabled | default(false) or
          linkerd_service_mesh.enabled | default(false)
        - kubernetes | default(false) | bool

    - name: check NFD configuration
      ansible.builtin.assert:
        that:
          - nfd_enabled
        fail_msg: "Deployment of Intel Device Plugins requires nfd_enabled set to 'true' in group_vars"
        success_msg: "NFD configuration verified"
      when:
        - (qat_dp_enabled | default(false)) or
          (sgx_dp_enabled | default(false)) or
          (gpu_dp_enabled | default(false))

    - name: check kmra.pccs.api_key presence
      ansible.builtin.assert:
        that:
          - kmra.pccs.api_key is defined
        fail_msg:
          - "Variable kmra.pccs.api_key is not defined"
        success_msg: "kmra.pccs.api_key presence is verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key length
      ansible.builtin.assert:
        that:
          - kmra.pccs.api_key | length == 32
        fail_msg: "PCCS API Key should be 32 bytes long"
        success_msg: "PCCS API key length verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key is not a placeholder
      ansible.builtin.assert:
        that:
          - kmra.pccs.api_key is defined
          - kmra.pccs.api_key != "ffffffffffffffffffffffffffffffff"
        fail_msg:
          - "Please, visit https://api.portal.trustedservices.intel.com/provisioning-certification and click on 'Subscribe'"
          - "to generate PCCS API key."
          - "PCCS API key is essential for KMRA PCCS deployment and usage."
        success_msg: "PCCS API key verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: aesmd-demo shouldn't be enabled if tcs is enabled
      ansible.builtin.assert:
        that: not sgx_aesmd_demo_enable | default(false)
        fail_msg: "Please, set 'sgx_aesmd_demo_enable' to 'false' because it conflicts with on-host aesmd daemon required by TCS."
      when:
        - tcs.enabled | default(false)

# Validate Hugepage settings
    - name: validate hugepage settings
      block:
        - name: validate default hugepage size setting
          ansible.builtin.assert:
            that: default_hugepage_size == "2M" or default_hugepage_size == "1G"
            fail_msg: "Valid sizes for hugepage are: [2M, 1G], given: {{ default_hugepage_size }}."

        - name: validate that at least one 1G hugepage is requested
          ansible.builtin.assert:
            that: number_of_hugepages_1G > 0
            fail_msg: "number_of_hugepages_1G should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "1G"

        - name: validate that at least one 2M hugepage is requested
          ansible.builtin.assert:
            that: number_of_hugepages_2M > 0
            fail_msg: "number_of_hugepages_2M should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "2M"
      when: hugepages_enabled | default(false) | bool

    - name: Check Userspace CNI preflight
      ansible.builtin.import_role:
        name: userspace_cni_install
        tasks_from: preflight.yml
      tags: userspace-cni
      when: userspace_cni_enabled | default(false)

# STORY: "If SST enabled, confirm minimum kernel or kernel_update specified"
    - name: check platform before SST-PP verification
      ansible.builtin.command: "cat /sys/devices/cpu/caps/pmu_name"
      when: sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
      changed_when: true
      register: verify_platform_for_sst_pp

    - name: check Intel(R) SST-PP (feature perf-profile) requirements
      ansible.builtin.assert:
        that:
          - (ansible_distribution == "Ubuntu" and ansible_distribution_version is version('20.04', '>=')) or
            (ansible_os_family == "RedHat" and ansible_distribution_version is version('8.3', '>='))
          - turbo_boost_enabled
        fail_msg:
          - "Playbook terminated cause of failure might to two reasons: Firstly, SST-PP is only supported in RedHat / Rocky >= 8.3 or Ubuntu >=20.04"
          - "To proceed further make sure sst_bf_configuration_enabled, sst_cp_configuration_enabled,"
          - "sst_tf_configuration_enable & sst_pp_configuration_enabled all should be disabled in host_vars"
          - "Secondly, make sure turbo_boost_enabled in host_vars is set to 'true', as required for turbo-freq configuration"
        success_msg: "Intel(R) SST-PP (feature perf-profile), verification completed"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' not in verify_platform_for_sst_pp.stdout"

    - name: Intel(R) SST-PP (feature perf-profile) not available
      ansible.builtin.fail:
        msg:
          - "SST-PP is not supported on {{ verify_platform_for_sst_pp.stdout }} platform"
          - "Make sure sst_pp_configuration_enabled is set to false in host vars"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' in verify_platform_for_sst_pp.stdout"

# STORY: Intel VT-d should be enabled in BIOS
    - name: check Intel VT-d on BMs
      block:
        - name: Check Intel VT-d
          ansible.builtin.shell: "set -o pipefail && dmesg | grep DMAR | grep remapping"
          args:
            executable: /bin/bash
          register: dmesg_dmar_remap
          changed_when: false
          failed_when: false

        - ansible.builtin.debug: msg="dmesg >> {{ dmesg_dmar_remap.stdout }}"

        - name: Check Intel VT-d via iommu_groups
          ansible.builtin.shell: "set -o pipefail && compgen -G \"/sys/kernel/iommu_groups/*/devices/*\" > /dev/null"
          args:
            executable: /bin/bash
          register: iommu_groups_out
          changed_when: false
          failed_when: false
          when:
            - dmesg_dmar_remap.stdout|length  == 0

        - name: Check intel_iommu on kernel commandline
          ansible.builtin.shell: "set -o pipefail && cat /proc/cmdline"
          args:
            executable: /bin/bash
          register: iommu_on_cmdline
          changed_when: false
          failed_when: false
          when:
            - dmesg_dmar_remap.stdout|length  == 0

        - ansible.builtin.debug:
            msg: "Result of 'Check Intel VT-d via iommu_groups' is not valid because of missing 'intel_iommu' parameter on kernel commandline"
          when:
            - dmesg_dmar_remap.stdout|length  == 0
            - iommu_groups_out.rc != 0
            - "'intel_iommu' not in iommu_on_cmdline.stdout"

        - name: warn about Intel VT-d
          ansible.builtin.fail:
            msg: "Warning: Intel VT-d appears DISABLED on target.  Please check BIOS under 'Advanced > Integrated IO Configuration' and Enable if necessary"
          when:
            - dmesg_dmar_remap.stdout|length  == 0
            - iommu_groups_out.rc != 0
      when:
        - on_vms is not defined or not on_vms
        - profile_name != "on_prem_aibox"

# STORY: Intel Virtualization Technology should be enabled in BIOS
    - name: check Intel Virtualization Technology on BMs
      block:
        - name: Check Intel Virtualization Technology
          ansible.builtin.shell: "set -o pipefail && lscpu | grep 'Virtualization:'"
          args:
            executable: /bin/bash
          register: virtualization_tech
          changed_when: false
          failed_when: false

        - ansible.builtin.debug: msg="{{ virtualization_tech.stdout }}"
          when:
            - virtualization_tech|length > 0

        - name: warn about Intel Virtualization Technology
          ansible.builtin.fail:
            msg: |
              "Warning: Intel Virtualization Technology is DISABLED on target."
              "Please check BIOS under 'Advanced > Processor Configuration' and Enable if necessary"
          when:
            - "'VT-x' not in virtualization_tech.stdout"
      when:
        - vm_enabled | default(false)
        - not configure_tdx | default(false)

# STORY: CPU Hyper-Threading should be enabled in BIOS
    - ansible.builtin.debug: msg="ansible_processor_threads_per_core={{ ansible_processor_threads_per_core }}"
    - ansible.builtin.debug: msg="CPU={{ ansible_processor[2] }} cores={{ ansible_processor_cores }} count={{ ansible_processor_count }} nproc={{ ansible_processor_nproc }} tpc={{ ansible_processor_threads_per_core }} vcpus={{ ansible_processor_vcpus }}" # noqa yaml[line-length]

    - name: warn about Hyper-Threading
      ansible.builtin.fail:
        msg: "Warning: Intel Hyper-Threading Tech is DISABLED on target. Please check BIOS under 'Advanced > Processor Configuration' and Enable if necessary"
      when:
        - ansible_processor_threads_per_core != 2
        - configured_arch not in ['atom', 'core', 'ultra']
        - profile_name not in ['on_prem_sw_defined_factory']

# STORY: "supported k8s versions require istio in >= 1.10"
    - name: fail if istio version is not compatible with current k8s version
      ansible.builtin.assert:
        that:
          - istio_service_mesh.version is version('1.10', '>=')
        msg: |
          "Selected Istio service mesh version: '{{ istio_service_mesh.version }}' is not compatible with selected k8s version: '{{ kube_version }}'"
          "Please, refer to the compatibility table at https://istio.io/latest/docs/releases/supported-releases/"
      when:
        - kubernetes
        - not container_runtime_only_deployment
        - istio_service_mesh is defined
        - istio_service_mesh.version is defined

# STORY: "TCS depends on sgx dp and cert manager"
    - name: check if sgx dp and cert manager are enabled when TCS enabled
      ansible.builtin.assert:
        that:
          - sgx_dp_enabled | default(false)
          - cert_manager_enabled | default(false)
        msg: "sgx_dp and cert manager should be enabled in order to have TCS functional."
      when:
        - tcs.enabled | default(false)
        - configured_arch in ['icx', 'spr']

# STORY: "TAC depends on TCS"
    - name: check if TCS is enabled when TAC enabled
      ansible.builtin.assert:
        that:
          - tcs.enabled | default(false)
          - kmra.apphsm.enabled | default(false)
          - kmra.pccs.enabled | default(false)
        msg: "TCS, KMRA AppHSM and PCCS should be enabled in order to have TAC functional."
      when:
        - tac.enabled | default(false)
        - configured_arch in ['icx', 'spr']

# STORY: "istio_service_mesh.sgx_signer' option is available only for icx, spr platforms"
    - name: particular service mesh options are available only for specific platforms
      ansible.builtin.assert:
        that:
          - not istio_service_mesh.sgx_signer.enabled | default(false)
        msg: "'istio_service_mesh.sgx_signer' option is not available for the configured platform architecture."
      when:
        - istio_service_mesh.enabled | default(false)
        - configured_arch not in ['icx', 'spr']

# STORY: "istio_service_mesh.sgx_signer' option must be true when profile is ca_custom"
    - name: particular service mesh options must be set together
      ansible.builtin.assert:
        that:
          - istio_service_mesh.sgx_signer.enabled | default(false)
        msg: "'istio_service_mesh.sgx_signer' must be enabled for custom-ca profile."
      when:
        - istio_service_mesh is defined
        - istio_service_mesh.enabled | default(false)
        - istio_service_mesh.profile == 'custom-ca' | default('default')
        - configured_arch in ['icx', 'spr']

# STORY: TCS is available only for icx, spr platforms"
    - name: TCS is available only for specific platforms
      ansible.builtin.assert:
        that:
          - not tcs.enabled | default(false)
        msg: "TCS is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx', 'spr']

    - name: Make sure istio and linkerd are not enabled at the same time
      ansible.builtin.assert:
        that:
          - not linkerd_service_mesh.enabled | default (false)
        fail_msg: "You should not have enabled Istio and LinkerD service mesh on at the same time.
                   Please choose and enable only one service mesh."
      when:
        - istio_service_mesh.enabled | default(false)

# STORY: TAC is available only for icx, spr platforms"
    - name: TAC is available only for specific platforms
      ansible.builtin.assert:
        that:
          - not tac.enabled | default(false)
        msg: "TAC is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx', 'spr']

# STORY: "istio_service_mesh.sgx_signer' option depends on KMRA AppHSM, KMRA PCCS, TCS, TAC.
    - name: check if KMRA Apps, TCS and TAC are enabled when service mesh sgx_signer option is enabled
      ansible.builtin.assert:
        that:
          - kmra.apphsm.enabled | default(false)
          - kmra.pccs.enabled | default(false)
          - tcs.enabled | default(false )
          - tac.enabled | default(false )
        msg: "In order to use service mesh sgx-signer option, please, enable KMRA AppHSM, KMRA PCCS, TCS, TAC."
      when:
        - istio_service_mesh.sgx_signer.enabled | default(false)
        - configured_arch in ['icx', 'spr']

    - name: check Kubernetes Power Manager configuration
      ansible.builtin.include_role:
        name: kubernetes_power_manager
        tasks_from: kpm_preflight
      when: kubernetes_power_manager is defined and kubernetes_power_manager.enabled

    - name: check Intel Ethernet Operator configuration
      ansible.builtin.include_role:
        name: intel_ethernet_operator
        tasks_from: preflight_ethernet_operator
      when: intel_ethernet_operator_enabled is defined and intel_ethernet_operator_enabled

    - name: make sure isolcpus and cpusets are not enabled simultaneously
      ansible.builtin.assert:
        that:
          - "[isolcpus_enabled, cpusets_enabled] is not all"
        msg:
          - "isolcpus_enabled and cpusets_enabled can't be enabled simultaneously."
          - "Please correct the host_vars configuration for target '{{ ansible_hostname }}'"
      when:
        - isolcpus_enabled is defined
        - cpusets_enabled is defined

    - name: check Intel SRIOV-FEC Operator requirements
      ansible.builtin.include_role:
        name: intel_sriov_fec_operator
        tasks_from: preflight_sriov_fec_operator
      when:
        - intel_sriov_fec_operator_enabled | default(false) | bool
        - intel_flexran_type != "pod"

    - name: check Intel FlexRAN requirements
      ansible.builtin.include_role:
        name: intel_flexran
        tasks_from: flexran_preflight
      when: intel_flexran_enabled | default(false) | bool

    - name: check Intel ECI requirements
      ansible.builtin.include_role:
        name: intel_eci
        tasks_from: eci_preflight
      when: intel_eci_enabled | default(false) | bool

    - name: check Intel CSL EXCAT requirements
      include_role:
        name: intel_csl_excat
        tasks_from: preflight
      when: intel_csl_excat_enabled | default(false) | bool

    - name: check OS when DLB or DSA is enabled
      ansible.builtin.assert:
        that:
          - (ansible_distribution == "Ubuntu" and ansible_distribution_version is version('20.04', '==')
            and (update_kernel or ansible_kernel[0:4] is version('5.14', '>='))) or
            (ansible_distribution == "Ubuntu" and ansible_distribution_version is version('22.04', '>=')) or
            (ansible_os_family == "RedHat" and ansible_distribution_version is version('8.6', '>='))
        success_msg: "DLB or DSA can succesfully be enabled on {{ ansible_distribution }} {{ ansible_distribution_version }}"
        msg: |
          DLB and DSA features are not supported on Ubuntu 20.04(with stock kernel) and RHEL/Rocky 8.5.
          {% if ansible_distribution == "Ubuntu" and ansible_kernel[0:4] is version('5.14', '<') %}
          Found {{ ansible_kernel[0:4] }} kernel on Ubuntu 20.04, but kernel in version 5.14 or higher is required.
          If you wish to use DLB or DSA feature set 'update_kernel' as true.
          {% endif %}
      when: configure_dsa_devices | d(false) or configure_dlb_devices | d(false)

# SGX on VMs require Ubuntu 22.04 for VM Host
    - name: Check requirements to enable Intel SGX on VMs
      block:
        - name: Intel SGX - check if ansible_host distro is Ubuntu 22.04
          ansible.builtin.assert:
            that:
              - ansible_distribution == "Ubuntu"
              - ansible_distribution_version is version('22.04', '==')
            msg: "Deploying SGX on VMRA is supported only on Ubuntu 22.04 VM host. Please change the o/s for VM host"

        - name: Check if configured SGX memory is not bigger than total memory
          ansible.builtin.assert:
            that:
              - item.memory > sgx_memory_size
            msg: |
              Improper memory configuration for vms.
              SGX memory size ({{ sgx_memory_size }}MB) can't be bigger than total memory ({{ item.memory }}MB) of VM: {{ item.name }}.
          with_items: "{{ vms }}"
          when:
            - item.type == "work"
      when:
        - vm_enabled | default(false)
        - sgx_dp_enabled | default(false)
        - inventory_hostname in groups['vm_host']

# Storage preflight check
    - name: check storage persistent volumes
      ansible.builtin.assert:
        that: persistent_volumes != []
        msg: "Persistent volumes on target '{{ ansible_hostname }}' must be set in host_vars. Please correct the configuration"
      when:
        - local_volume_provisioner_enabled | default(false) or
          rook_ceph.enabled | default(false) or
          minio_enabled | default(false)
        - not storage_deploy_test_mode | default(false)
        - storage_nodes | default([]) | length == 0 or
          inventory_hostname in storage_nodes | default([])

# TDX preflight check
    - name: check tdx requirement
      include_role:
        name: bootstrap/install_tdx_drivers # noqa role-name[path] - role in bootstrap
        tasks_from: tdx_preflight.yml
      when:
        - configure_tdx | default(false)
        - not on_vms | default(false)

    - name: check Intel ECI VM Operating System
      assert:
        that:
          - vm_image_distribution | default("ubuntu") == "ubuntu"
          - vm_image_version_ubuntu | default("22.04") == "22.04"
      when: intel_eci_enabled | default(false) | bool

# STORY: Check requirements for Intel Media Transport Library
    - name: check Intel Media Transport Library requirements
      ansible.builtin.include_role:
        name: imtl_install
        tasks_from: preflight.yml
      when: intel_media_transport_library_enabled | default(false)

####################################
# Prerequisites for FlexRAN BM oRU #
####################################
- hosts: oru
  any_errors_fatal: true
  tasks:
    - name: check Intel FlexRAN requirements
      ansible.builtin.include_role:
        name: intel_flexran
        tasks_from: flexran_preflight
      when:
        - intel_flexran_enabled | default(false)
        - intel_flexran_type == "host"
        - intel_flexran_mode == "xran"

####################################
# Prerequisites for Role specific  #
####################################
- hosts: k8s_cluster
  any_errors_fatal: true
  tasks:
    - name: Include Sigstore policy controller checks
      ansible.builtin.import_role:
        name: sigstore_policy_controller
        tasks_from: preflight.yml
      when: sigstore_policy_controller_install | default(false) | bool

    - name: Include oneAPI kits checks
      ansible.builtin.import_role:
        name: intel_oneapi_install
        tasks_from: preflight.yml
      tags: intel-oneapi
      when: intel_oneapi_enabled | default(false) | bool

    - name: Check Kibana configuration
      ansible.builtin.include_role:
        name: kibana_install
        tasks_from: preflight
      when: kibana_enabled | default(false)

    - name: Check Jaeger configuration
      ansible.builtin.include_role:
        name: jaeger_install
        tasks_from: preflight
      when: jaeger_enabled | default(false)

    - name: Check OpenTelemetry configuration
      ansible.builtin.include_role:
        name: opentelemetry_install
        tasks_from: preflight
      when: opentelemetry_enabled | default(false)

    - name: Check Telegraf configuration
      ansible.builtin.include_role:
        name: telegraf_install
        tasks_from: preflight
      when: telegraf_enabled | default(false)

    - name: Check Collectd configuration
      ansible.builtin.include_role:
        name: collectd_install
        tasks_from: preflight
      when: collectd_enabled | default(false)

    - name: Check cAdvisor configuration
      ansible.builtin.include_role:
        name: cadvisor_install
        tasks_from: preflight
      when: cadvisor_enabled | default(false)

    - name: Check XPUManager configuration
      ansible.builtin.include_role:
        name: intel_xpumanager
        tasks_from: xpumanager_preflight
      when: intel_xpumanager_enabled | default(false)

    - name: check ADQ configuration
      ansible.builtin.include_role:
        name: adq_dp_install
        tasks_from: preflight_adq
      when: adq_dp.enabled | default(false)

    - name: check Calico VPP configuration
      ansible.builtin.include_role:
        name: calico_vpp_install
        tasks_from: calico_vpp_preflight
      when: calico_vpp.enabled | default(false)

# STORY: "MinIO requires number of nodes should be more than the minimum number of nodes defined in group_vars/all/minio_tenant_servers"
    - name: display MinIO requirement with multus-service
      ansible.builtin.fail:
        msg: |
          MinIO deployment for k8s service on additional interfaces with multiple interface/Multus CNI(multus-service) requires:
           - group_vars/kube_network_plugin: flannel
           - group_vars/container_runtime: crio
           - group_vars/minio_build_image_locally: true
           - host_vars/dataplane_interfaces should be defined
           - host_vars/dataplane_interfaces[*].minio_vf:true on interfaces
           - host_vars/dataplane_interfaces[*].sriov_vfs[*].vf_0: 'iaxf' on interfaces
           - SRIOV network ports should be connected with VEB/VEPA enabled
      run_once: yes
      tags: minio
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled
      failed_when: false

    # When MinIO enabled, container runtime should be set to crio
    - name: Check requirements for MinIO
      ansible.builtin.assert:
        that:
          - container_runtime == "crio"
          - (kube_network_plugin == "flannel") or
            (kube_network_plugin == "calico" and calico_network_backend == "vxlan")
          - minio_build_image_locally
        fail_msg: |
          Following parameters needs to be set if MinIO is enabled:
          - group_vars/container_runtime: crio
          - group_vars/kube_network_plugin: flannel or
          - group_vars/kube_network_plugin: calico and calico_network_backend: vxlan
          - group_vars/minio_build_image_locally: true
          Current values are:
          - group_vars/container_runtime: {{ container_runtime }}
          - group_vars/kube_network_plugin: {{ kube_network_plugin }}
          - group_vars/calico_network_backend: {{ calico_network_backend }}
          - group_vars/minio_build_image_locally: {{ minio_build_image_locally }}
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - name: Check that MinIO on additional interfaces with multiple interfaces configuration is not used
      ansible.builtin.assert:
        that:
          - kube_network_plugin != "flannel"
          - dataplane_interfaces | default([]) | rejectattr('minio_vf', 'defined') | list | length == 0
          - dataplane_interfaces | default([]) | selectattr('minio_vf', '==', True) | list | length == 0
        fail_msg: |
          MinIO on additional interfaces with multiple interfaces configuration is currently not supported.
          Please set following to configure MinIO only for default interfaces:
          - uncomment minio_vfs for every dataplane interface in host_vars
          - set minio_vfs to false for every dataplane interface in host_vars
          - set kube_netvork_plugin to calico in group_vars
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - name: check MinIO configuration
      ansible.builtin.import_role:
        name: minio_install
        tasks_from: preflight_minio_main
      tags: minio
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

# STORY: Check Intent Driven Orchestration (IDO) dependencies
    - name: assert that all IDO dependencies are enabled
      assert:
        that:
          - registry_enable | default(false)
          - linkerd_service_mesh.enabled | d(false)
        fail_msg: |
          Local Docker registry (registry_enable) and LinkerD (linkerd_service_mesh.enable) must be enabled when using IDO.
      when:
        - ido.enabled | default(false)

    - ansible.builtin.meta: end_play
#    - name: Print all variables/facts known for a host
#      ansible.builtin.debug:
#        var: hostvars[inventory_hostname]
#        verbosity: 4
