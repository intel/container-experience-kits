##
##   Copyright (c) 2020-2023 Intel Corporation.
##
##   Licensed under the Apache License, Version 2.0 (the "License");
##   you may not use this file except in compliance with the License.
##   You may obtain a copy of the License at
##
##       http://www.apache.org/licenses/LICENSE-2.0
##
##   Unless required by applicable law or agreed to in writing, software
##   distributed under the License is distributed on an "AS IS" BASIS,
##   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##   See the License for the specific language governing permissions and
##   limitations under the License.
##
---
# Preflight: ALL checks must PASS
# Only assert issues (do NOT change anything)
#
# Manual run: 'ansible-playbook -i inventory.ini playbooks/preflight.yml --flush-cache'
#
# Summary:
# On Ansible Host (localhost):
# - Check Ansible version (match)
# - Check Python version (min)
# - Check Group Vars (exist)
# - Check Host Vars (exist for each worker node)
# On All targets (k8s_cluster):
# - Check Linux Distro
# - Check Hostnames (match Inventory)
# - Check if cpusets and isolcpus are enabled simultaneously
# - Check cpusets Total (not more than actual)
# - Check cpusets IDs (valid on system)
# - Check cpusets OS Reserved (not 0,1,etc)
# - Check isolcpus Total (not more than actual)
# - Check isolcpus IDs (valid on system)
# - Check isolcpus OS Reserved (not 0,1,etc)
# On Worker Nodes Only (kube_node):
# - Check DP Interfaces (is not empty)
# - Check DP Interfaces Name (optional)
# - Check DP Interfaces Bus Info (pciid)
# - Check QAT Devices Bus Info (pciid)
# - Check QAT SRIOV VFs (max)
# - Check SGX configuration
# - Check OVS DPDK Dependencies (for 1G Hugepages)
# - Check VPP Dependencies (for 2M Hugepages)
# - Check CNI Dependencies (for OVS DPDK or VPP and Hugepages)
# - Check SST (not on RHEL 8.2 or old OSs)
# - Check Linux distro for cstates
# - Warn BIOS VT-d (should be enabled)
# - Warn BIOS Intel Virtualization Technology (should be enabled)
# - Warn BIOS Hyper-Threading (should be enabled)
# - Warn collectd (kernel update needed on old OSs)
# - Check OVS DPDK Version Compatibility (for OVS support)
# - Check Intel Ethernet Operator configuration
# - Check Intel SR-IOV FEC Operator configuration
# On Role specific Only (k8s_cluster)
# - Check Observability compontents
# - Check MinIO requirements


# additional vars required:
#  cek_supported_ansible_base: # must be version
#  cek_supported_python: # min version
#  cek_supported_distros: [] # list
#  cek_supported_distros_versions: [] # list


##################################
# Prerequisites for Ansible Host #
##################################
- hosts: 127.0.0.1
  any_errors_fatal: true
  connection: local
  become: false
  vars:
    cek_supported_ansible_base: 2.11.8
    cek_supported_python: 3

  tasks:

    - debug: msg="Ansible version is {{ ansible_version.string }}"
    - name: Check Ansible Version
      assert:
        that: (ansible_version.full is version_compare(cek_supported_ansible_base, '>='))
        msg: "Ansible version must be {{ cek_supported_ansible_base }}. Please update"

    - debug: msg="Python version is {{ ansible_python_version }}"
    - name: Check Python Version
      assert:
        that: (ansible_python_version is version_compare(cek_supported_python, '>='))
        msg: "Python version must be at least {{ cek_supported_python }}. Please update"

    - name: read Group Vars
      stat:
        path: "{{ inventory_dir }}/group_vars/"
      register: group_vars_details

    - name: Check Group Vars
      assert:
        that: "group_vars_details.stat.exists and group_vars_details.stat.isdir"
        msg: "File group_vars/all.yml does NOT exist. Must be created per Guide"

    - name: read Host Vars
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: host_vars_details
      with_items: "{{ groups['kube_node'] }}"

    - name: check Host Vars
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ host_vars_details.results }}"

    - name: read VM Host Vars
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: vm_host_vars_details
      with_items: "{{ groups['vm_host'] }}"

    - name: check VM Host Vars
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"

    - name: set group_vars_profile variable
      set_fact:
        group_vars_profile: "{{ profile_name | default('not generated') }}"

    - name: show profile_name from group_vars
      debug:
        msg: "group_vars profile_name is: '{{ group_vars_profile }}'"

    - name: check ip is defined in inventory.ini
      shell: "set -o pipefail && cat {{ inventory_file }} | grep -v \"^#\""
      args:
        executable: /bin/bash
      changed_when: false
      failed_when: check_ip_status.rc != 0
      register: check_ip_status
      when: vm_enabled and (not on_vms | default(false))

    - name: handle the error for check passwordless access to VM hosts
      block:
        - name: check passwordless access to VM hosts
          command: >-
            ssh -o PasswordAuthentication=no {{ hostvars[item]['ansible_user'] | default(ansible_env.USER, True) }}@{{ hostvars[item]['ip'] }}
            /bin/true
          with_items: "{{ groups['vm_host'] }}"
          changed_when: false
      rescue:
        - name: Print when passwordless authentication failed
          debug:
            msg: >
              "Current user: '{{ ansible_env.USER }}' does not have password less access to '{{ (ansible_failed_result.results[0].stderr).split(':')[0] }}'.
               Password less authentication have to be configured for all VM hosts. Use: 'ssh-copy-id <user>@<VM_host_ip>'
              See above, which one failed"
          failed_when: true
      when:
        - vm_enabled and (not on_vms | default(false))
        - "'ip=' in check_ip_status.stdout | regex_findall('^' + item + '.*$', multiline=True, ignorecase=True) | join(',')"

    # VMRA FQDN block in case if IP is not defined in inventory.ini
    - name: handle the error for checking hostname and passwordless access to VM hosts via hostname
      block:
        - name: set hostname configuration
          set_fact:
            hostname_check: "{{ ansible_hostname }}"
            hostname_fqdn_check: "{{ ansible_fqdn }}"
          with_items: "{{ groups['vm_host'] }}"

        - name: verify user defined hostname in inventory with in system hostname configuration
          assert:
            that:
              - (ansible_host == hostname_fqdn_check) or
                (ansible_host == hostname_check)
            fail_msg:
              - "Found hostname configuration in system not equal to user defined hostname in inventory {{ ansible_host }}"
              - "Please update correct hostname in inventory.ini"
            success_msg: "{{ ansible_host }} matches with hostname configuration found in system"
          with_items: "{{ groups['vm_host'] }}"

        - name: check passwordless access to VM hosts via FQDN
          command: >-
            ssh -o PasswordAuthentication=no {{ hostvars[item]['ansible_user'] | default(ansible_env.USER, True) }}@{{ hostvars[item]['ansible_host'] }}
            /bin/true
          changed_when: false
          with_items: "{{ groups['vm_host'] }}"
      rescue:
        - name: Print when passwordless authentication failed
          debug:
            msg: >
              "Current user: '{{ ansible_env.USER }}' does not have password less access to '{{ (ansible_failed_result.results[0].stderr).split(':')[0] }}'.
               Password less authentication have to be configured for all VM hosts. Use: 'ssh-copy-id <user>@<VM_host_hostname>'
              See above, which one failed"
          failed_when: true
      when:
        - vm_enabled and (not on_vms | default(false))
        - ansible_host is defined
        - "'ip=' not in check_ip_status.stdout | regex_findall('^' + item + '.*$', multiline=True, ignorecase=True) | join(',')"

    - name: check scale variable value
      assert:
        that: "{{ scale | bool }}"
        fail_msg: "scale variable must be set to one of the following values { yes, on, 1, true }, case insensitive"
        success_msg: "scale variable is set to {{ scale }} \ncluster scaling is enabled"
      when: scale is defined

    - name: check vm_recreate_existing variable value
      assert:
        that: "not {{ vm_recreate_existing | bool }}"
        fail_msg: "vm_recreate_existing has to be false for cluster scaling case"
        success_msg: "vm_recreate_existing variable is set to {{ vm_recreate_existing }} for cluster scaling"
      when:
        - scale is defined
        - vm_enabled | default(false)

##############################################
# Prerequisites for Control and Worker Nodes #
##############################################
- hosts: k8s_cluster,vm_host
  any_errors_fatal: true
  gather_facts: true
  vars:
    cek_supported_distros: [RedHat, Rocky, Ubuntu]
    cek_supported_distros_versions: ['8.6', '9.0', '9.1', '22.04']
    cpusets_ranges: []
    cpusets_discretes: []
    isolcpus_ranges: []
    isolcpus_discretes: []
    isolcpus_list: []

  tasks:
    - name: end play for VM host
      meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

    - name: fail if deployment is VMRA and isolcpus is enabled
      assert:
        that:
          - isolcpus is not defined
        fail_msg:
          - "isolcpus variable can't be used on VMRA deployment"
      when:
        - vm_enabled and (not on_vms | default(false))
        - isolcpus_enabled

    - name: read Host Vars for VMs
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item.name }}.yml"
      register: vm_host_vars_details
      with_items: "{{ vms }}"
      delegate_to: localhost
      become: false
      when:
        - vm_enabled and (not on_vms | default(false))
        - item.type == 'work'

    - name: check Host Vars for VMs
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item.name }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"
      when:
        - vm_enabled and (not on_vms | default(false))
        - vm_host_vars_details
        - not item.skipped | default(false)

    - name: Check VM root password
      block:
        - name: check vm_hashed_passwd presence
          assert:
            that:
              - vm_hashed_passwd is defined
            fail_msg:
              - "Variable vm_hashed_passwd is not defined"
            success_msg: "vm_hashed_passwd is present"

        - name: check vm_hashed_passwd is not a placeholder
          assert:
            that:
              - vm_hashed_passwd is defined
              - vm_hashed_passwd != "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
            fail_msg:
              - "vm_hashed_passwd was not set with hashed password. Create hashed password and run deployment again."
            success_msg: "vm_hashed_passwd verified"
      when:
        - vm_enabled and (not on_vms | default(false))

# VMs multinode setup for VM Hosts
    - name: Check requirements to enable VMs multinode setup
      when:
        - vm_enabled and (not on_vms | default(false))
        - "groups['vm_host'] | length > 1"
      block:
        - name: check if mandatory parameter 'vxlan_physical_network' is present for the first vm_host
          assert:
            that:
              - "hostvars[groups['vm_host'][0]]['vxlan_physical_network'] is defined"
            msg: |
              "vxlan_physical_network parameter is not defined for the first vm_host '{{ groups['vm_host'][0] }}'"
              "Please correct the configuration"
          run_once: true

        - name: check if mandatory parameter 'vxlan_physical_network' for the first vm_host has valid IP subnet
          assert:
            that:
              - "hostvars[groups['vm_host'][0]]['vxlan_physical_network'] | ansible.utils.ipaddr('net')"
            msg: |
              "vxlan_physical_network parameter for the first vm_host '{{ groups['vm_host'][0] }}' does not have valid IP subnet"
              "Current value is '{{ hostvars[groups['vm_host'][0]]['vxlan_physical_network'] }}'"
              "Please correct the configuration"
          run_once: true

        - name: check if VXLAN physical network is available
          assert:
            that: "hostvars[inventory_hostname]['ansible_all_ipv4_addresses'] | ansible.utils.ipaddr(hostvars[groups['vm_host'][0]]['vxlan_physical_network']) |
                   length > 0 "
            msg: |
              "vxlan_physical_network '{{ hostvars[groups['vm_host'][0]]['vxlan_physical_network'] }}' is not available on vm_host '{{ inventory_hostname }}'"
              "Please correct the configuration or update network setup to ensure proper connectivity between vm_hosts"

    - name: check for ip and ansible_host mismatch
      assert:
        that: "ansible_host == ip"
        msg: "Configuration mismatch detected between ansible_host={{ ansible_host }} and ip={{ ip }} on target '{{ inventory_hostname }}'"
      when:
        - ansible_host is defined
        - ip is defined
        - ansible_host | ansible.utils.ipaddr('bool')
        - not adq_dp['enabled'] | default(false)

    - debug: msg="Linux distribution on target is {{ ansible_distribution }} {{ ansible_distribution_version }} {{ ansible_distribution_release }}"
    - name: Check Linux Distro and Version
      assert:
        that: "ansible_distribution in cek_supported_distros and ansible_distribution_version in cek_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}' is NOT supported
          - Must be one of {{ cek_supported_distros }} and version {{ cek_supported_distros_versions }}
      when: on_cloud is not defined or not on_cloud

#    - name: Check Linux Across Cluster
# TODO ?? Linux OS must be the same on all targets (no mix-n-match)

    - name: regather network facts in case hostname recently changed
      setup:
        gather_subset: network
    - debug: msg="Inventory target '{{ inventory_hostname }}' has the actual system hostname '{{ ansible_hostname }}'"
    - name: Check Inventory Hostnames
      debug:
        msg:
          - "Target '{{ inventory_hostname }}' in inventory does NOT match the actual system hostname '{{ ansible_hostname }}'."
          - "If it's done intentionally, please ignore this message."
      when:
        - inventory_hostname != ansible_hostname

# Early check if SELinux is configured properly
    - block:
        - name: "Collect packages facts"
          package_facts:
        - debug:
            msg:
              - "Current SELinux status:"
              - "status: {{ ansible_selinux.status | default('') }}"
              - "policy version:  {{ ansible_selinux.policyvers | default('') }}"
              - "type: {{ ansible_selinux.type | default('') }}"
              - "mode: {{ ansible_selinux.mode | default('') }}"
              - "config_mode: {{ ansible_selinux.config_mode | default('') }}"

        - name: check SELinux condition possibly causing system boot failure
          debug:
            msg:
              - "Current SELinux setup might cause the system possibly will not boot up on next reboot."
              - "Please, check SELinux settings and set it up according to the documentation."
          when:
            - "'selinux-policy' not in ansible_facts.packages"
            - "'selinux-policy-targeted' not in ansible_facts.packages"

        - name: check SELinux configuration for CRI-O runtime
          assert:
            that:
              - (ansible_selinux.status == "enabled" and selinux_state is defined and selinux_state == "disabled") or
                (ansible_selinux.status != "enabled" and selinux_state is defined and selinux_state != "enabled")
            fail_msg: "CRI-O runtime requires SELinux in disabled state. Please, set selinux_state variable to 'disabled'"
            success_msg: "CRI-O runtime SELinux configuration verified"
          when:
            - container_runtime == "crio"
      when:
        - ansible_os_family == "RedHat"

    - name: check kubernetes and container runtime variables
      assert:
        that:
          - (not kubernetes and container_runtime_only_deployment) or
            (not kubernetes and not container_runtime_only_deployment)
        fail_msg: >-
          "For container runtime only deployment set container_runtime_only_deployment as "true" and kubernetes as "false".
          Set both variables as "false" to perform only host configuration."
      when:
        - not kubernetes or container_runtime_only_deployment

    - name: check k8s version
      assert:
        that: "{{ kube_version is version('v1.22', '>=') }}"
        msg: "Minimum supported k8s version is 1.22, please update kube_version variable with correct version"
      when: kubernetes and not container_runtime_only_deployment

    - name: assert that Multus is enabled in the config
      assert:
        that:
          - "kube_network_plugin_multus"
        fail_msg: "SRIOV and the Userspace CNI plugin require Multus for a fully functional cluster deployment"
      when: sriov_net_dp_enabled is defined and sriov_net_dp_enabled or
            sriov_cni_enabled is defined and sriov_cni_enabled or
            userspace_cni_enabled is defined and userspace_cni_enabled

    - name: assert that SRIOV Network Operator/SRIOV Network DP are mutually exclusive
      assert:
        that:
          - "not sriov_net_dp_enabled"
        fail_msg:
          - "SRIOV Network Operator is enabled, SRIOV Network DP/SRIOV CNI should be disabled !!"
      when: sriov_network_operator_enabled is defined and sriov_network_operator_enabled

# check cpusets CPU core/threads shielding configuration
    - block:
        - debug:
            msg:
              - cpusets_enabled = {{ cpusets_enabled }} (host_vars)
              - cpusets = {{ cpusets }} (host_vars)
              - ansible_processor_count = {{ ansible_processor_count }}
              - ansible_processor_cores = {{ ansible_processor_cores }}
              - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
              - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
              - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}
  #            - CPUs Reserved for OS = {{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }} # [E207] Nested jinja pattern

        - name: check OS for cpusets based on cgroups v1 only
          assert:
            that:
              - (ansible_distribution == 'Ubuntu' and ansible_distribution_version == '20.04')
            msg:
              - Unsupported configuration.
              - CPUs isolation ('cpusets') can be only enabled on Ubuntu 20.04.x.

        - name: check CPUs isolation
          assert:
            that: ( "{{ cpusets }}" | length > 0 )
            msg:
              - Incorrect configuration. Conflicting or improper values detected
              - CPUs isolation ('cpusets') must be set according to the example file for host_vars. Please correct the configuration

        - name: split cpusets Groups
          set_fact:
            cpusets_groups: "{{ cpusets.split(',') }}"

        - debug: msg="cpusets_groups = {{ cpusets_groups }}"

        - name: filter cpusets Ranges
          set_fact:
            cpusets_ranges: "{{ cpusets_ranges + [item] }}"
          with_items: "{{ cpusets_groups }}"
          when: ("-" in item)

        - debug: msg="cpusets_ranges = {{ cpusets_ranges }}"

        - name: filter cpusets Discretes
          set_fact:
            cpusets_discretes: "{{ cpusets_discretes + [item] }}"
          with_items: "{{ cpusets_groups }}"
          when: ("-" not in item)

        - debug: msg="cpusets_discretes = {{ cpusets_discretes }}"

        - name: build cpusets List
          set_fact:
            cpusets_list: "{{ cpusets_list | default([]) | union(cpusets_discretes) | union([item]) }}"
          with_sequence: "{{ cpusets_ranges }}"

        - debug: msg="cpusets_list = {{ cpusets_list }}"

        - name: check cpusets Total
          assert:
            that: "{{ cpusets_list | length }} <= ansible_processor_vcpus"
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The number of cpusets {{ cpusets_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

        - name: check cpusets IDs
          assert:
            that: "item | int <= ansible_processor_vcpus"
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The CPU ID {{ item }} set for cpusets is NOT actually present on target. Please correct the configuration
          with_items: "{{ cpusets_list }}"

        - name: check cpusets OS Reserved
          assert:
            that: "item not in cpusets_list"
            msg:
              - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
              - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for cpusets. Please correct the configuration
          with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - cpusets_enabled is defined and cpusets_enabled | bool

# check isolcpus CPU core/threads configuration
    - block:
        - debug:
            msg:
              - isolcpus_enabled = {{ isolcpus_enabled }} (host_vars)
              - isolcpus = {{ isolcpus }} (host_vars)
              - ansible_processor_count = {{ ansible_processor_count }}
              - ansible_processor_cores = {{ ansible_processor_cores }}
              - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
              - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
              - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}
  #            - CPUs Reserved for OS = {{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }} # [E207] Nested jinja pattern

        - name: check CPUs isolation
          assert:
            that: ( "{{ isolcpus }}" | length > 0 )
            msg:
              - Incorrect configuration. Conflicting or improper values detected
              - CPUs isolation ('isolcpus') must be set according to the example file for host_vars. Please correct the configuration

        - name: split isolcpus Groups
          set_fact:
            isolcpus_groups: "{{ isolcpus.split(',') }}"

        - debug: msg="isolcpus_groups = {{ isolcpus_groups }}"

        - name: filter isolcpus Ranges
          set_fact:
            isolcpus_ranges: "{{ isolcpus_ranges + [item] }}"
          with_items: "{{ isolcpus_groups }}"
          when: ("-" in item)

        - debug: msg="isolcpus_ranges = {{ isolcpus_ranges }}"

        - name: filter isolcpus Discretes
          set_fact:
            isolcpus_discretes: "{{ isolcpus_discretes + [item] }}"
          with_items: "{{ isolcpus_groups }}"
          when: ("-" not in item)

        - debug: msg="isolcpus_discretes = {{ isolcpus_discretes }}"

        - name: build isolcpus List
          set_fact:
            isolcpus_list: "{{ isolcpus_list | default([]) | union(isolcpus_discretes) | union([item]) }}"
          with_sequence: "{{ isolcpus_ranges }}"

        - debug: msg="isolcpus_list = {{ isolcpus_list }}"

        - name: check isolcpus Total
          assert:
            that: "{{ isolcpus_list | length }} <= ansible_processor_vcpus"
            msg: |
              Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              The number of isolcpus {{ isolcpus_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

        - name: check isolcpus IDs
          assert:
            that: "item | int <= ansible_processor_vcpus"
            msg:
              - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              - The CPU ID {{ item }} set for isolcpus is NOT actually present on target. Please correct the configuration
          with_items: "{{ isolcpus_list }}"

        - name: check isolcpus OS Reserved
          assert:
            that: "item not in isolcpus_list"
            msg:
              - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
              - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for isolcpus. Please correct the configuration
          with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - isolcpus_enabled is defined and isolcpus_enabled | bool
        - isolcpus is defined and isolcpus

    - name: check Intel CPU Control Plane configuration
      include_role:
        name: intel_cpu_controlplane
        tasks_from: preflight_cpu_controlplane.yml
      when:
        - kubernetes
        - intel_cpu_controlplane is defined and intel_cpu_controlplane.enabled
      tags:
        - cpu_ctlplane

    - name: check Intel AI configuration
      import_role:
        name: intel_ai
        tasks_from: preflight_intel_ai.yml
      when:
        - kubernetes
        - intel_ai_enabled | default(false)
      tags:
        - intel-ai

####################################
# Prerequisites for Worker Node(s) #
####################################
- hosts: kube_node,vm_host
  any_errors_fatal: true
  vars:
    cstates_supported_distros: [Ubuntu]
    cstates_supported_distros_versions: ['22.04']
    phy_nics_pciids: []
  vars_files:
    - "roles/check_machine_type/vars/main.yml"

  tasks:
    - name: end play for VM host
      meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

# STORY: "nic bus info specified is present on system"
    - debug:
        msg: "Dataplane (DP) interface(s) defined in host_vars = {{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined

    - name: assert that (SRIOV Network DP/SRIOV CNI) and (SRIOV Network Operator) are mutually exclusive
      assert:
        that: "not (sriov_net_dp_enabled and (sriov_network_operator_enabled | default(false)))"
        fail_msg:
          - "SRIOV Network DP/SRIOV CNI and SRIOV Network Operator are mutually exclusive. One must be disabled"
      when:
        - (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_net_dp_enabled is defined and sriov_net_dp_enabled)

    - name: check DP Interfaces
      assert:
        that: "dataplane_interfaces != []"
        msg: "Dataplane (DP) interface(s) on target '{{ ansible_hostname }}' must be set in host_vars. Please correct the configuration"
      when:
        - profile_name != 'build_your_own'
        - dataplane_interfaces is defined
        - (update_nic_drivers is defined and update_nic_drivers) or
          (install_ddp_packages is defined and install_ddp_packages) or
          (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_network_operator_enabled is defined and sriov_network_operator_enabled)

    - debug:
        msg: "Network interfaces present on target '{{ ansible_hostname }}' = {{ ansible_interfaces }}"

    - name: read Physical NICs PCIIDs
      set_fact:
        phy_nics_pciids: "{{ phy_nics_pciids + [ ansible_facts[item]['pciid'] ] }}"
      with_items: "{{ ansible_interfaces }}"
      when: ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"

    - debug: msg="PCI Slots for the NICs on target '{{ ansible_hostname }}' = {{ phy_nics_pciids }}"

    - name: check DP Interfaces Bus Info
      assert:
        that: ("{{ item.bus_info }}" in "{{ phy_nics_pciids }}")
        msg: "Dataplane interface defined with PCI ID '{{ item.bus_info }}' does NOT exist on target. Please correct the configuration"
      with_items: "{{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined and dataplane_interfaces != []

    - name: check invalid driver for CNDP on DP Interfaces
      assert:
        that: ("{{ item.pf_driver }}" in "['i40e', 'ice', 'iavf']")
        msg: >-
          "Dataplane interface defined with PCI ID '{{ item.bus_info }}' have unssupported pf_driver '{{ item.pf_driver }}' for CNDP.
          Please correct the configuration. Supported pf_drivers are ['i40e', 'ice', 'iavf']"
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - cndp_dp_enabled | default(false) | bool

    - name: load firmware specific variables
      include_vars: "../roles/bootstrap/update_nic_firmware/defaults/main.yml"
      when: nvmupdate is not defined

    - name: check nic firmware version needed for loading of DDP profile
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_ddp_loadable_fw_version }}"
        ddp: true
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - install_ddp_packages is defined and install_ddp_packages
        - not update_nic_firmware | default(false)

    - name: check nic firmware version needed for automatic firmware update
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_updatable_fw_version }}"
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - update_nic_firmware | default(false)

    - name: Check first DP interface driver and DDP package
      block:
        - name: Check first DP interface driver
          assert:
            that: "dataplane_interfaces[0].pf_driver == ansible_facts[item]['module']"
            msg: >-
              "Dataplane interface '{{ dataplane_interfaces[0].bus_info }}' 'pf_driver' is set to '{{ dataplane_interfaces[0].pf_driver }}'.
              Please, set it to '{{ ansible_facts[item]['module'] }}'."
          loop: "{{ ansible_interfaces }}"
          when:
            - ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"
            - dataplane_interfaces[0].bus_info in ansible_facts[item]['pciid']

        - name: check if selected DDP package corresponds PF driver ice
          assert:
            that: "{{ dataplane_interfaces[0].ddp_profile is regex('^ice_comms*') }}"
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "ice"
            - install_ddp_packages is defined and install_ddp_packages

        - name: check if selected DDP package corresponds PF driver i40e
          assert:
            that: "{{ dataplane_interfaces[0].ddp_profile in ddp_profiles_allowed }}"
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "i40e"
            - install_ddp_packages is defined and install_ddp_packages
          vars:
            ddp_profiles_allowed:
              - ecpri.pkg
              - esp-ah.pkg
              - ppp-oe-ol2tpv2.pkgo
              - mplsogreudp.pkg
              - gtp.pkgo
      when:
        - dataplane_interfaces is defined and dataplane_interfaces | length > 0

    - name: Print processor info
      debug:
        msg: "ansible_processor model: {{ ansible_processor[2] }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: set CPU ID in preflight
      set_fact:
        cpu_id: "{{ ansible_processor[2] | regex_search('\\$?\\d\\d\\d\\d\\%?\\@?\\w?|\\d\\d/\\d\\w') }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: print CPU ID
      debug:
        msg: "CPU ID: {{ cpu_id }}"
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: check if CPU has confirmed support (preflight)
      assert:
        that: "cpu_id in {{ lookup('ansible.builtin.vars', 'confirmed_' + configured_arch + '_cpus') }} \
               {% if configured_arch == 'clx' %} or cpu_id in {{ confirmed_clx_ncpus }} {% endif %} \
               or cpu_id in {{ unconfirmed_cpu_models }}"
        fail_msg:
          "CPU model '{{ cpu_id }}' present on target is not in the confirmed CPUs list.\n
          To proceed, please add  '{{ cpu_id }}' to the list of unconfirmed CPUs in variable 'unconfirmed_cpu_models' in group_vars.\n
          Please be aware that by using CPU model that is not confirmed, some features may not work properly."
      when: (not vm_enabled) or (vm_enabled and (not on_vms | default(false)))

    - name: check QAT Devices list is configured properly
      block:
        - debug:
            msg: "QAT device(s) defined in host_vars = {{ qat_devices }}"

        - name: read QAT PCIIDs
          shell: "set -o pipefail && lshw -businfo -numeric | egrep -i '{{ qat_supported_pf_dev_ids | join('|') }}'"
          args:
            executable: /bin/bash
          register: lshw_qat_host
          changed_when: false
          failed_when: false
          when:
            - on_vms is not defined or not on_vms

        - name: assert QAT PCIIDs
          assert:
            that: "lshw_qat_host.rc == 0"
            fail_msg: "No QAT devices were found in system. Please configure properly the QAT PCIIDs in group_vars or disable this feature"
            success_msg: "QAT PCIIDs verification completed"
          when:
            - on_vms is not defined or not on_vms

        - name: read QAT PCIIDs on VMs
          shell: "set -o pipefail && lshw -businfo -numeric | egrep -i '{{ (qat_supported_vf_dev_ids + qat_supported_pf_dev_ids) | join('|') }}'"
          args:
            executable: /bin/bash
          register: lshw_qat_vms
          changed_when: false
          when:
            - on_vms is defined and on_vms

        - name: store lshw_qat
          set_fact:
            lshw_qat: "{% if (on_vms is defined and on_vms) %}{{ lshw_qat_vms }}{% else %}{{ lshw_qat_host }}{% endif %}"

        - debug:
            msg: "QAT devices found on target = {{ lshw_qat.stdout }}"

        - name: check QAT Devices' Bus Info
          assert:
            that: ("{{ item.qat_id }}" in """{{ lshw_qat.stdout }}""")
            msg: "QAT device defined with PCI ID '{{ item.qat_id }}' does NOT exist on target. Please correct the configuration"
          with_items: "{{ qat_devices }}"
        # STORY: "qat_sriov_numvfs should not exceed max supported (16) per each dev_ID"
        - debug:
            msg:
              - qat_sriov_numvfs for {{ item.qat_id }} = {{ item.qat_sriov_numvfs }} (host_vars)
              - update_qat_drivers = {{ update_qat_drivers }} (host_vars)
          with_items: "{{ qat_devices }}"

        - name: check QAT SRIOV VFs
          assert:
            that: ({{ item.qat_sriov_numvfs }} <= 16)
            msg:
              - Incorrect configuration pertaining QAT SRIOV. Conflicting or improper values detected
              - When SRIOV VFs are set for QAT, max value is 16 for each ID (max 48 total per card). Please correct the configuration
          with_items: "{{ qat_devices }}"
      when:
        - update_qat_drivers is defined and update_qat_drivers
        - qat_devices is defined and qat_devices != []

    - name: check QAT SRIOV VFs requirement for qat device auto detection
      assert:
        that: ({{ qat_sriov_numvfs_required }} <= 16)
        msg:
          - Incorrect configuration in qat_sriov_numvfs_required for requested number of QAT VTs
          - When SRIOV VFs are set for QAT, max value is 16 for each ID (max 48 total per card). Please correct the configuration
      when:
        - update_qat_drivers is defined and update_qat_drivers
        - qat_devices is defined and qat_devices == []

    - name: Check GPU hardware requirements
      include_role:
        name: gpu_dp_install
        tasks_from: preflight_gpu_dp
      when:
        - gpu_dp_enabled is defined and gpu_dp_enabled

    - name: Check GPU device plugin state
      assert:
        that:
          - gpu_dp_enabled
        fail_msg: "GPU device plugin is disabled. Please set gpu_dp_enabled to true in group_vars."
        success_msg: "GPU device plugin is enabled"
      when: configure_gpu is defined and configure_gpu

# OpenSSL & OpenSSL*Engine must only be configured / installed when update_qat_drivers is set to 'true' and qat_devices is defined in host vars
# or auto-detected from the system
    - name: check OpenSSL and OpenSSL*Engine requirements
      assert:
        that:
          - update_qat_drivers
        fail_msg: "OpenSSL & OpenSSL*Engine will only configured if update_qat_drivers is set to 'true'"
        success_msg: "OpenSSL & OpenSSL*Engine verification completed"
      when: openssl_install is defined and openssl_install

    - name: check KMRA sgx_dp requirements
      assert:
        that:
          - sgx_dp_enabled
        fail_msg: "KMRA installation requires sgx_dp_enabled set to 'true'"
        success_msg: "KMRA requirements verified"
      when:
        - kmra.ctk_loadkey_demo.enabled | default(false) or
          kmra.pccs.enabled | default(false) or
          kmra.apphsm.enabled | default(false)

    - name: check Intel SGX DP configuration
      assert:
        that:
          - configure_sgx is defined
          - configure_sgx
        fail_msg:
          - "Please set configure_sgx to true in host vars to allow SGX configuration on the system"
      when:
        - sgx_dp_enabled is defined and sgx_dp_enabled

    - name: check if Cert Manager is required
      assert:
        that:
          - cert_manager_enabled | default(false)
        fail_msg:
          - "Cert Manager required by following components: Intel Device Plugins, observability stack, NFD, LinkerD."
          - "Please set cert_manager_enabled to 'true' in group_vars"
        success_msg: "Cert Manager is enabled as required"
      when:
        - nfd_enabled | default(false) or
          sgx_dp_enabled | default(false) or
          dlb_dp_enabled | default(false) or
          qat_dp_enabled | default(false) or
          gpu_dp_enabled | default(false) or
          dsa_dp_enabled | default(false) or
          qat_dp_enabled | default(false) or
          jaeger_operator | default(false) or
          telegraf_enabled | default(false) or
          prometheus_operator | default(false) or
          opentelemetry_enabled | default(false) or
          elasticsearch_enabled | default(false) or
          linkerd_service_mesh.enabled | default(false)

    - name: check NFD configuration
      assert:
        that:
          - nfd_enabled
        fail_msg: "Deployment of Intel Device Plugins requires nfd_enabled set to 'true' in group_vars"
        success_msg: "NFD configuration verified"
      when:
        - (qat_dp_enabled | default(false)) or
          (sgx_dp_enabled | default(false)) or
          (gpu_dp_enabled | default(false))

    - name: check kmra.pccs.api_key presence
      assert:
        that:
          - kmra.pccs.api_key is defined
        fail_msg:
          - "Variable kmra.pccs.api_key is not defined"
        success_msg: "kmra.pccs.api_key presence is verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key length
      assert:
        that:
          - kmra.pccs.api_key | length == 32
        fail_msg: "PCCS API Key should be 32 bytes long"
        success_msg: "PCCS API key length verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key is not a placeholder
      assert:
        that:
          - kmra.pccs.api_key is defined
          - kmra.pccs.api_key != "ffffffffffffffffffffffffffffffff"
        fail_msg:
          - "Please, visit https://api.portal.trustedservices.intel.com/provisioning-certification and click on 'Subscribe'"
          - "to generate PCCS API key."
          - "PCCS API key is essential for KMRA PCCS deployment and usage."
        success_msg: "PCCS API key verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: aesmd-demo shouldn't be enabled if tcs is enabled
      assert:
        that: not sgx_aesmd_demo_enable | default(false)
        fail_msg: "Please, set 'sgx_aesmd_demo_enable' to 'false' because it conflicts with on-host aesmd daemon required by TCS."
      when:
        - tcs.enabled | default(false)

# Validate Hugepage settings
    - name: validate hugepage settings
      block:
        - name: validate default hugepage size setting
          assert:
            that: default_hugepage_size == "2M" or default_hugepage_size == "1G"
            fail_msg: "Valid sizes for hugepage are: [2M, 1G], given: {{ default_hugepage_size }}."

        - name: validate that at least one 1G hugepage is requested
          assert:
            that: number_of_hugepages_1G > 0
            fail_msg: "number_of_hugepages_1G should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "1G"

        - name: validate that at least one 2M hugepage is requested
          assert:
            that: number_of_hugepages_2M > 0
            fail_msg: "number_of_hugepages_2M should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "2M"
      when: hugepages_enabled | default(false) | bool

# STORY: "vpp/ovsdpdk require hugepage enabled and configured"
    - debug:
        msg:
          - vpp_enabled = {{ vpp_enabled }} (host_vars)
          - ansible_distribution = {{ ansible_distribution }} (basic facts)
          - ansible_distribution_version = {{ ansible_distribution_version }} (basic facts)
          - example_net_attach_defs = {{ example_net_attach_defs }} (group_vars/all.yml)
          - userspace_ovs_dpdk = {{ example_net_attach_defs['userspace_ovs_dpdk'] }} (group_vars/all.yml)
          - userspace_vpp = {{ example_net_attach_defs['userspace_vpp'] }} (group_vars/all.yml)
          - sriov_net_dp = {{ example_net_attach_defs['sriov_net_dp'] }} (group_vars/all.yml)
          - userspace_cni_enabled = {{ userspace_cni_enabled }} (host_vars)
          - sriov_cni_enabled = {{ sriov_cni_enabled }} (host_vars)
          - sriov_network_operator_enabled = {{ sriov_network_operator_enabled }} (host_vars)
          - bond_cni_enabled = {{ bond_cni_enabled }} (host_vars)
          - ovs_dpdk_enabled = {{ ovs_dpdk_enabled }} (host_vars)
          - userspace_cni_enabled = {{ userspace_cni_enabled }} (host_vars)
          - hugepages_enabled = {{ hugepages_enabled }} (host_vars)
          - default_hugepage_size = {{ default_hugepage_size }} (host_vars)
          - number_of_hugepages_1G = {{ number_of_hugepages_1G }} (host_vars)
          - number_of_hugepages_2M = {{ number_of_hugepages_2M }} (host_vars)
      when: vpp_enabled is defined and vpp_enabled # host_vars

    - name: check OS for VPP compilation
      assert:
        that:
          - (ansible_distribution == 'Ubuntu' and ansible_distribution_version >= '22.04')
        msg: "Unsupported configuration. VPP can be only enabled on Ubuntu >= 22.04"
      when: vpp_enabled is defined and vpp_enabled

    - name: check OVS DPDK Dependencies
      assert:
        that: >-
          ({{ ovs_dpdk_enabled }} and not {{ vpp_enabled }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "1G" and {{ number_of_hugepages_1G }} >= 0)
          or {{ vpp_enabled }}
        msg:
          - Incorrect configuration pertaining OVS DPDK. Conflicting or improper values detected
          - When OVS DPDK is enabled, VPP must be disabled and default_hugepage_size must be set to 1G according to host_vars example.
          - Also check these conditions in group_vars, example_net_attach_defs['userspace_ovs_dpdk']=true, example_net_attach_defs['userspace_vpp']=false.
          - Please correct the configuration
      when: ovs_dpdk_enabled is defined and ovs_dpdk_enabled

    - name: check VPP Dependencies
      assert:
        that: >-
          ({{ vpp_enabled }} and not {{ ovs_dpdk_enabled }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "2M" and {{ number_of_hugepages_2M }} >= 0)
          or {{ ovs_dpdk_enabled }}
        msg:
          - Incorrect configuration pertaining VPP. Conflicting or improper values detected
          - When VPP is enabled, OVS DPDK must be disabled and default_hugepage_size must be set to 2M according to host_vars example.
          - Also check these conditions in group_vars, example_net_attach_defs['userspace_ovs_dpdk']=false, example_net_attach_defs['userspace_vpp']=true.
          - Please correct the configuration.
      when: vpp_enabled is defined and vpp_enabled


# STORY: "cnis require net-attach-defs to be enabled"
    - name: check CNI Config
      assert:
        that: >-
          ({{ userspace_cni_enabled }} and {{ ovs_dpdk_enabled }} and {{ example_net_attach_defs['userspace_ovs_dpdk'] }} and not {{ vpp_enabled }} and
          not {{ example_net_attach_defs['userspace_vpp'] }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "1G" and {{ number_of_hugepages_1G }} >= 0)
          or ({{ userspace_cni_enabled }} and not {{ ovs_dpdk_enabled }} and not {{ example_net_attach_defs['userspace_ovs_dpdk'] }} and {{ vpp_enabled }}
          and {{ example_net_attach_defs['userspace_vpp'] }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "2M" and {{ number_of_hugepages_2M }} >= 0)
        msg:
          - Incorrect configuration pertaining CNI. Conflicting or improper values detected.
          - When Userspace CNI is enabled, either OVS DPDK or VPP must be enabled, default_hugepage_size must also set under these options.
          - 1. If VPP is enabled, ovs_dpdk_enabled=false, default_hugepage_size = 2M in host_vars; and
          - example_net_attach_defs['userspace_ovs_dpdk']=false, example_net_attach_defs['userspace_vpp']=true in group_vars.
          - 2. If OVS DPDK is enabled, default_hugepage_size = 1G in host_vars; and
          - vpp_enabled=false, example_net_attach_defs['userspace_ovs_dpdk']=true, example_net_attach_defs['userspace_vpp']=false in group_vars.
          - Please correct the configuration.
      when: userspace_cni_enabled is defined and userspace_cni_enabled


# STORY: "If SST enabled, confirm minimum kernel or kernel_update specified"
    - name: check platform before SST-PP verification
      command: "cat /sys/devices/cpu/caps/pmu_name"
      when: sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
      changed_when: true
      register: verify_platform_for_sst_pp

    - name: check Intel(R) SST-PP (feature perf-profile) requirements
      assert:
        that:
          - (ansible_distribution == "Ubuntu" and ansible_distribution_version >= "20.04") or
            (ansible_os_family == "RedHat" and ansible_distribution_version >= "8.3")
          - turbo_boost_enabled
        fail_msg:
          - "Playbook terminated cause of failure might to two reasons: Firstly, SST-PP is only supported in RedHat / Rocky >= 8.3 or Ubuntu >=20.04"
          - "To proceed further make sure sst_bf_configuration_enabled, sst_cp_configuration_enabled,"
          - "sst_tf_configuration_enable & sst_pp_configuration_enabled all should be disabled in host_vars"
          - "Secondly, make sure turbo_boost_enabled in host_vars is set to 'true', as required for turbo-freq configuration"
        success_msg: "Intel(R) SST-PP (feature perf-profile), verification completed"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' not in verify_platform_for_sst_pp.stdout"

    - name: Intel(R) SST-PP (feature perf-profile) not available
      fail:
        msg:
          - "SST-PP is not supported on {{ verify_platform_for_sst_pp.stdout }} platform"
          - "Make sure sst_pp_configuration_enabled is set to false in host vars"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' in verify_platform_for_sst_pp.stdout"


# Cstates are supported only with kernel version >= 5.13
    - name: Check if distribution is supported by cstates
      assert:
        that: "ansible_distribution in cstates_supported_distros and ansible_distribution_version in cstates_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}' does NOT support cstates
          - Must be one of {{ cstates_supported_distros }} and version {{ cstates_supported_distros_versions }}
      when: cstate_enabled is defined and cstate_enabled


# Uncore frequency scaling is supported only with kernel version >= 5.13
    - name: Check if distribution is supported by uncore frequency scaling
      assert:
        that: "ansible_distribution in cstates_supported_distros and ansible_distribution_version in cstates_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}'
          - does NOT support uncore frequency scaling
          - Must be one of {{ cstates_supported_distros }} and version {{ cstates_supported_distros_versions }}
      when: ufs_enabled is defined and ufs_enabled


# STORY: Intel VT-d should be enabled in BIOS
    - name: check Intel VT-d on BMs
      block:
        - name: Check Intel VT-d
          shell: "set -o pipefail && dmesg | grep DMAR | grep remapping"
          args:
            executable: /bin/bash
          register: dmesg_dmar_remap
          changed_when: false
          failed_when: false

        - debug: msg="dmesg >> {{ dmesg_dmar_remap.stdout }}"

        - name: Check Intel VT-d via iommu_groups
          shell: "set -o pipefail && compgen -G \"/sys/kernel/iommu_groups/*/devices/*\" > /dev/null"
          args:
            executable: /bin/bash
          register: iommu_groups_out
          changed_when: false
          failed_when: false
          when:
            - dmesg_dmar_remap.stdout|length  == 0

        - name: Check intel_iommu on kernel commandline
          shell: "set -o pipefail && cat /proc/cmdline"
          args:
            executable: /bin/bash
          register: iommu_on_cmdline
          changed_when: false
          failed_when: false
          when:
            - dmesg_dmar_remap.stdout|length  == 0

        - debug: msg="Result of 'Check Intel VT-d via iommu_groups' is not valid because of missing 'intel_iommu' parameter on kernel commandline"
          when:
            - dmesg_dmar_remap.stdout|length  == 0
            - iommu_groups_out.rc != 0
            - "'intel_iommu' not in iommu_on_cmdline.stdout"

        - name: warn about Intel VT-d
          fail:
            msg: "Warning: Intel VT-d appears DISABLED on target.  Please check BIOS under 'Advanced > Integrated IO Configuration' and Enable if necessary"
          when:
            - dmesg_dmar_remap.stdout|length  == 0
            - iommu_groups_out.rc != 0
      when:
        - on_vms is not defined or not on_vms
        - on_cloud is not defined or not on_cloud

# STORY: Intel Virtualization Technology should be enabled in BIOS
    - name: check Intel Virtualization Technology on BMs
      block:
        - name: Check Intel Virtualization Technology
          shell: "set -o pipefail && lscpu | grep 'Virtualization:'"
          args:
            executable: /bin/bash
          register: virtualization_tech
          changed_when: false
          failed_when: false

        - debug: msg="{{ virtualization_tech.stdout }}"
          when:
            - virtualization_tech|length > 0

        - name: warn about Intel Virtualization Technology
          fail:
            msg: |
              "Warning: Intel Virtualization Technology is DISABLED on target."
              "Please check BIOS under 'Advanced > Processor Configuration' and Enable if necessary"
          when:
            - "'VT-x' not in virtualization_tech.stdout"
      when:
        - vm_enabled | default(false)
        - on_cloud is not defined or not on_cloud

# STORY: CPU Hyper-Threading should be enabled in BIOS
    - name: warn about Hyper-Threading
      fail:
        msg: "Warning: Intel Hyper-Threading Tech is DISABLED on target.  Please check BIOS under 'Advanced > Processor Configuration' and Enable if necessary"
      when:
        - ansible_processor_threads_per_core != 2
        - on_cloud is not defined or not on_cloud

# STORY: "collectd and telegraf are mutually exclusive"
    - name: fail if collectd and telegraf are both enabled
      assert:
        that: >-
          (({{ collectd_enabled | bool }}) and (not ({{ telegraf_enabled | bool }})))
          or (not {{ collectd_enabled | bool }} and {{ telegraf_enabled | bool }})
          or (not {{ collectd_enabled | bool }} and (not ({{ telegraf_enabled | bool }})))
        msg: "CollectD and Telegraf are mutually exclusive, please enable only one."
      when:
        - collectd_enabled is defined
        - telegraf_enabled is defined

# STORY: "supported k8s versions require istio in >= 1.10"
    - name: fail if istio version is not compatible with current k8s version
      assert:
        that:
          - "{{ istio_service_mesh.version is version('1.10', '>=') }}"
        msg: |
          "Selected Istio service mesh version: '{{ istio_service_mesh.version }}' is not compatible with selected k8s version: '{{ kube_version }}'"
          "Please, refer to the compatibility table at https://istio.io/latest/docs/releases/supported-releases/"
      when:
        - kubernetes
        - not container_runtime_only_deployment
        - istio_service_mesh is defined
        - istio_service_mesh.version is defined
# STORY: "TCS depends on KMRA AppHSM and KMRA PCCS"
    - name: check if KMRA Apps are enabled when TCS is enabled
      assert:
        that:
          - "{{ kmra.apphsm.enabled | default(false) }}"
          - "{{ kmra.pccs.enabled | default(false) }}"
        msg: "KMRA AppHSM and PCCS applications should be enabled in order to have TCS functional."
      when:
        - tcs.enabled | default(false) or tac.enabled | default(false)
        - configured_arch in ['icx']

# STORY: "TAC depends on TCS"
    - name: check if TCS is enabled when TAC enabled
      assert:
        that:
          - "{{ tcs.enabled | default(false ) }}"
        msg: "TCS should be enabled in order to have TAC functional."
      when:
        - tac.enabled | default(false)
        - configured_arch in ['icx']

# STORY: "istio_service_mesh.sgx_signer' option is available only for icx platforms"
    - name: particular service mesh options are available only for specific platforms
      assert:
        that:
          - "{{ not istio_service_mesh.sgx_signer.enabled | default(false) }}"
        msg: "'istio_service_mesh.sgx_signer' option is not available for the configured platform architecture."
      when:
        - istio_service_mesh.enabled | default(false)
        - configured_arch not in ['icx']

# STORY: TCS is available only for icx platforms"
    - name: TCS is available only for specific platforms
      assert:
        that:
          - "{{ not tcs.enabled | default(false) }}"
        msg: "TCS is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx']

    - name: Make sure istio and linkerd are not enabled at the same time
      assert:
        that:
          - "{{ not linkerd_service_mesh.enabled | default (false) }}"
        fail_msg: "You should not have enabled Istio and LinkerD service mesh on at the same time.
                   Please choose and enable only one service mesh."
      when:
        - istio_service_mesh.enabled | default(false)

# STORY: TAC is available only for icx platforms"
    - name: TAC is available only for specific platforms
      assert:
        that:
          - "{{ not tac.enabled | default(false) }}"
        msg: "TAC is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx']

# STORY: "istio_service_mesh.sgx_signer' option depends on KMRA AppHSM, KMRA PCCS, TCS, TAC.
    - name: check if KMRA Apps, TCS and TAC are enabled when service mesh sgx_signer option is enabled
      assert:
        that:
          - "{{ kmra.apphsm.enabled | default(false) }}"
          - "{{ kmra.pccs.enabled | default(false) }}"
          - "{{ tcs.enabled | default(false ) }}"
          - "{{ tac.enabled | default(false ) }}"
        msg: "In order to use service mesh sgx-signer option, please, enable KMRA AppHSM, KMRA PCCS, TCS, TAC."
      when:
        - istio_service_mesh.sgx_signer.enabled | default(false)
        - configured_arch in ['icx']

# STORY: TEMPORARY: "ovs dpdk version requirements"
    - debug:
        msg:
          - install_dpdk = {{ install_dpdk }} (host_vars)
          - dpdk_version = {{ dpdk_version }} (host_vars)
          - ovs_dpdk_enabled = {{ ovs_dpdk_enabled }} (host_vars)
          - ovs_version = {{ ovs_version }} (host_vars)
      when:
        - install_dpdk is defined # host_vars
        - dpdk_version is defined # host_vars
        - ovs_version is defined # host_vars
        - ovs_dpdk_enabled is defined and ovs_dpdk_enabled # host_vars

    - name: check OVS DPDK compatibility
      assert:
        that:
          (ovs_version >= 'v2.17.0' and ovs_version <= 'v3.0.3') and (dpdk_version >= '21.11' and dpdk_version <= '22.07')
          or (ovs_version < 'v2.16.2' and ovs_version >= 'v2.16.0') and dpdk_version == '21.08'
          or ovs_version == 'v2.15.0' and dpdk_version == '20.11'
          or ovs_version == 'v2.14.2' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.14.1' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.14.0' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.3' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.2' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.1' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.0' and dpdk_version == '19.11.6'
        msg: "OVS {{ ovs_version }} does not build with DPDK version {{ dpdk_version }}. Please correct the host_vars configuration"
      when:
        - dpdk_version is defined # host_vars
        - ovs_version is defined # host_vars
        - ovs_dpdk_enabled is defined and ovs_dpdk_enabled # host_vars

    - name: check settings for Intel Power Manager
      assert:
        that:
          - intel_power_manager.power_profiles | length > 0
          - intel_power_manager.power_nodes | length > 0
        fail_msg: "Intel Power Manager is enabled, but either Power Profiles or Power Nodes are not specified in group vars."
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if power_nodes are available in inventory
      assert:
        that:
          - item in groups['kube_node']
        fail_msg: "Intel Power Manager power_nodes have to be present in inventory. '{{ item }}' is not there: {{ groups['kube_node'] }}"
      loop: "{{ intel_power_manager.power_nodes }}"
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if Intel Power Manager is enabled, the ISST features should be disabled
      assert:
        that:
          - not (sst_bf_configuration_enabled is defined and sst_bf_configuration_enabled or
            sst_cp_configuration_enabled is defined and sst_cp_configuration_enabled or
            sst_tf_configuration_enabled is defined and sst_tf_configuration_enabled or
            sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled)
        fail_msg:
          - "Currently Intel Power Manager and Intel SST features are mutually exclusive."
          - "Please disable ISST (SST-BF, SST-CP, SST-TF and SST-PP) in host vars."
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if Intel Power Manager is build locally on containerd/cri-o runtime
      assert:
        that: intel_power_manager.build_image_locally
        fail_msg:
          - "Currently Intel Power Manager must be build locally on containerd and cri-o runtime"
          - "Please set build_image_locally as true in Intel Power Manager settings in group_vars"
      when: intel_power_manager is defined and intel_power_manager.enabled and container_runtime in ["crio", "containerd"]

    - name: check Intel Ethernet Operator configuration
      include_role:
        name: intel_ethernet_operator
        tasks_from: preflight_ethernet_operator
      when: intel_ethernet_operator_enabled is defined and intel_ethernet_operator_enabled

    - name: make sure isolcpus and cpusets are not enabled simultaneously
      assert:
        that:
          - (not isolcpus_enabled and cpusets_enabled) or
            (isolcpus_enabled and not cpusets_enabled)
        msg:
          - "isolcpus_enabled and cpusets_enabled can't be enabled simultaneously."
          - "Please correct the host_vars configuration for target '{{ ansible_hostname }}'"
      when:
        - (isolcpus_enabled is defined and isolcpus_enabled) or
          (cpusets_enabled is defined and cpusets_enabled)

    - name: check Intel SRIOV-FEC Operator requirements
      include_role:
        name: intel_sriov_fec_operator
        tasks_from: preflight_sriov_fec_operator
      when: intel_sriov_fec_operator_enabled | default(false) | bool

    - name: check Intel FlexRAN requirements
      include_role:
        name: intel_flexran
        tasks_from: flexran_preflight
      when: intel_flexran_enabled | default(false)

    - name: check OS when DLB or DSA is enabled
      assert:
        that:
          - (ansible_distribution == "Ubuntu" and ansible_distribution_version == '20.04'
            and (update_kernel or ansible_kernel[0:4] is version('5.14', '>='))) or
            (ansible_distribution == "Ubuntu" and ansible_distribution_version >= '22.04') or
            (ansible_os_family == "RedHat" and ansible_distribution_version >= '8.6')
        success_msg: "DLB or DSA can succesfully be enabled on {{ ansible_distribution }} {{ ansible_distribution_version }}"
        msg: |
          DLB and DSA features are not supported on Ubuntu 20.04(with stock kernel) and RHEL/Rocky 8.5.
          {% if ansible_distribution == "Ubuntu" and ansible_kernel[0:4] is version('5.14', '<') %}
          Found {{ ansible_kernel[0:4] }} kernel on Ubuntu 20.04, but kernel in version 5.14 or higher is required.
          If you wish to use DLB or DSA feature set 'update_kernel' as true.
          {% endif %}
      when: configure_dsa_devices | d(false) or configure_dlb_devices | d(false)
# SGX on VMs require Ubuntu 22.04 for VM Host
    - name: Check requirements to enable Intel SGX on VMs
      block:
        - name: Intel SGX - check if ansible_host distro is Ubuntu 22.04
          assert:
            that:
              - ansible_distribution == "Ubuntu"
              - ansible_distribution_version == "22.04"
            msg: "Deploying SGX on VMRA is supported only on Ubuntu 22.04 VM host. Please change the o/s for VM host"
      when:
        - vm_enabled | default(false)
        - sgx_dp_enabled | default(false)
        - inventory_hostname in groups['vm_host']

####################################
# Prerequisites for FlexRAN BM oRU #
####################################
- hosts: oru
  any_errors_fatal: true
  tasks:
    - name: check Intel FlexRAN requirements
      include_role:
        name: intel_flexran
        tasks_from: flexran_preflight
      when:
        - intel_flexran_enabled | default(false)
        - intel_flexran_type == "host"
        - intel_flexran_mode == "xran"

####################################
# Prerequisites for Role specific  #
####################################
- hosts: k8s_cluster
  any_errors_fatal: true
  tasks:

# STORY: "Observability: assert that all required compontents are enabled"
    - name: assert that all observability/monitoring variables are disabled
      assert:
        that:
          - not elasticsearch_enabled | default(false)
          - not jaeger_operator | default(false)
          - not opentelemetry_enabled | default(false)
          - not kibana_enabled | default(false)
        fail_msg: |
          When both telegraf and collectd are disabled then the rest of Observability stack needs to be disabled: elastisearch, jaeger, opentelemtry and kibana.
      when:
        - not telegraf_enabled | default(false)
        - not collectd_enabled | default(false)

    - name: assert that all observability/monitoring variables are enabled for telegraf
      assert:
        that:
          - telegraf_enabled | default(false)
          - elasticsearch_enabled | default(false)
          - jaeger_operator | default(false)
          - opentelemetry_enabled | default(false)
          - kibana_enabled | default(false)
        fail_msg: |
          Observability needs to be enabled as a stack: telegraf, elastisearch, jaeger, opentelemtry and kibana.
      when:
        - telegraf_enabled | default(false)

    - name: assert that all observability/monitoring variables are disabled for collectd
      assert:
        that:
          - not telegraf_enabled | default(false)
          - not elasticsearch_enabled | default(false)
          - not jaeger_operator | default(false)
          - not opentelemetry_enabled | default(false)
          - not kibana_enabled | default(false)
        fail_msg: |
          When collectd is enabled then Observability stack needs to be disabled: telegraf, elastisearch, jaeger, opentelemtry and kibana.
      when:
        - collectd_enabled | default(false)

    - name: check ADQ configuration
      include_role:
        name: adq_dp_install
        tasks_from: preflight_adq
      when: adq_dp.enabled | default(false)

# STORY: "MinIO requires number of nodes should be more than the minimum number of nodes defined in group_vars/all/minio_tenant_servers"
    - name: display MinIO requirement with multus-service
      fail:
        msg: |
          MinIO deployment for k8s service on additional interfaces with multiple interface/Multus CNI(multus-service) requires:
           - group_vars/kube_network_plugin: flannel
           - group_vars/container_runtime: crio
           - group_vars/minio_build_image_locally: true
           - host_vars/dataplane_interfaces should be defined
           - host_vars/dataplane_interfaces[*].minio_vf:true on interfaces
           - host_vars/dataplane_interfaces[*].sriov_vfs[*].vf_0: 'iaxf' on interfaces
           - SRIOV network ports should be connected with VEB/VEPA enabled
      run_once: yes
      tags: minio
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled
      failed_when: false

    # When MinIO enabled, container runtime should be set to crio
    - name: Check requirements for MinIO
      assert:
        that:
          - container_runtime == "crio"
          - (kube_network_plugin == "flannel") or
            (kube_network_plugin == "calico" and calico_network_backend == "vxlan")
          - minio_build_image_locally
        fail_msg: |
          Following parameters needs to be set if MinIO is enabled:
          - group_vars/container_runtime: crio
          - group_vars/kube_network_plugin: flannel or
          - group_vars/kube_network_plugin: calico and calico_network_backend: vxlan
          - group_vars/minio_build_image_locally: true
          Current values are:
          - group_vars/container_runtime: {{ container_runtime }}
          - group_vars/kube_network_plugin: {{ kube_network_plugin }}
          - group_vars/calico_network_backend: {{ calico_network_backend }}
          - group_vars/minio_build_image_locally: {{ minio_build_image_locally }}
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - name: Check that MinIO on additional interfaces with multiple interfaces configuration is not used
      ansible.builtin.assert:
        that:
          - kube_network_plugin != "flannel"
          - dataplane_interfaces | default([]) | rejectattr('minio_vf', 'defined') | list | length == 0
          - dataplane_interfaces | default([]) | selectattr('minio_vf', '==', True) | list | length == 0
        fail_msg: |
          MinIO on additional interfaces with multiple interfaces configuration is currently not supported.
          Please set following to configure MinIO only for default interfaces:
          - uncomment minio_vfs for every dataplane interface in host_vars
          - set minio_vfs to false for every dataplane interface in host_vars
          - set kube_netvork_plugin to calico in group_vars
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - name: check MinIO configuration
      import_role:
        name: minio_install
        tasks_from: preflight_minio_main
      tags: minio
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - meta: end_play
#    - name: Print all variables/facts known for a host
#      ansible.builtin.debug:
#        var: hostvars[inventory_hostname]
#        verbosity: 4
